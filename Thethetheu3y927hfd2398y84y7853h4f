-- SKIDDED FUCKING UI LEAKED BY DESKTOP2677
-- MODIFIED BY GEMINI TO MOVE TABS TO TOP AND ADD FADE (v2 - Fixed vararg error)

-- Library init
getgenv().library = {
    folders = {
        "/fonts",
        "/configs",
    },
    Flags = {},
    config_flags = {},
    connections = {},
    notifications = {notifs = {}},
    current_open,
}

local keys = {
    [Enum.KeyCode.LeftShift] = "LS",
    [Enum.KeyCode.RightShift] = "RS",
    [Enum.KeyCode.LeftControl] = "LC",
    [Enum.KeyCode.RightControl] = "RC",
    [Enum.KeyCode.Insert] = "INS",
    [Enum.KeyCode.Backspace] = "BS",
    [Enum.KeyCode.Return] = "Ent",
    [Enum.KeyCode.LeftAlt] = "LA",
    [Enum.KeyCode.RightAlt] = "RA",
    [Enum.KeyCode.CapsLock] = "CAPS",
    [Enum.KeyCode.One] = "1",
    [Enum.KeyCode.Two] = "2",
    [Enum.KeyCode.Three] = "3",
    [Enum.KeyCode.Four] = "4",
    [Enum.KeyCode.Five] = "5",
    [Enum.KeyCode.Six] = "6",
    [Enum.KeyCode.Seven] = "7",
    [Enum.KeyCode.Eight] = "8",
    [Enum.KeyCode.Nine] = "9",
    [Enum.KeyCode.Zero] = "0",
    [Enum.KeyCode.KeypadOne] = "Num1",
    [Enum.KeyCode.KeypadTwo] = "Num2",
    [Enum.KeyCode.KeypadThree] = "Num3",
    [Enum.KeyCode.KeypadFour] = "Num4",
    [Enum.KeyCode.KeypadFive] = "Num5",
    [Enum.KeyCode.KeypadSix] = "Num6",
    [Enum.KeyCode.KeypadSeven] = "Num7",
    [Enum.KeyCode.KeypadEight] = "Num8",
    [Enum.KeyCode.KeypadNine] = "Num9",
    [Enum.KeyCode.KeypadZero] = "Num0",
    [Enum.KeyCode.Minus] = "-",
    [Enum.KeyCode.Equals] = "=",
    [Enum.KeyCode.Tilde] = "~",
    [Enum.KeyCode.LeftBracket] = "[",
    [Enum.KeyCode.RightBracket] = "]",
    [Enum.KeyCode.RightParenthesis] = ")",
    [Enum.KeyCode.LeftParenthesis] = "(",
    [Enum.KeyCode.Semicolon] = ",",
     [Enum.KeyCode.Quote] = "'",
    [Enum.KeyCode.BackSlash] = "\\",
    [Enum.KeyCode.Comma] = ",",
    [Enum.KeyCode.Period] = ".",
    [Enum.KeyCode.Slash] = "/",
    [Enum.KeyCode.Asterisk] = "*",
    [Enum.KeyCode.Plus] = "+",
    [Enum.KeyCode.Period] = ".",
    [Enum.KeyCode.Backquote] = "`",
    [Enum.UserInputType.MouseButton1] = "MB1",
    [Enum.UserInputType.MouseButton2] = "MB2",
    [Enum.UserInputType.MouseButton3] = "MB3",
    [Enum.KeyCode.Escape] = "ESC",
    [Enum.KeyCode.Space] = "SPC",
}

library.__index = library

for _, path in next, library.folders do
    makefolder("syphon" .. path)
end

local flags = library.Flags
local config_flags = library.config_flags
local notifications = library.notifications

do -- Font importing system
    writefile("syphon" .. "/fonts/main.ttf", game:HttpGet("https://github.com/f1nobe7650/Nebula/raw/refs/heads/main/Minecraftia-Regular.ttf"))

    local minecraftia = {
        name = "Minecraftia",
        faces = {
            {
                name = "Regular",
 weight = 400,
                style = "normal",
                assetId = getcustomasset("syphon/fonts/main.ttf")
            }
        }
    }

    if not isfile("syphon" .. "/fonts/main_encoded.ttf") then
        writefile("syphon" .. "/fonts/main_encoded.ttf", game:GetService("HttpService"):JSONEncode(minecraftia))
    end

 library.font = Font.new(getcustomasset("syphon" .. "/fonts/main_encoded.ttf"), Enum.FontWeight.Regular)
end

do -- Library functions & Misc functions
    function library:tween(obj, properties, easing_style, time)
        local tween = game:GetService("TweenService"):Create(obj, TweenInfo.new(time or 0.1, easing_style or Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0), properties):Play()

        return tween
    end

    function library:resizify(frame)
        local Frame = Instance.new("TextButton")
        Frame.Position = UDim2.new(1, -10, 1, -10)
     Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
        Frame.Size = UDim2.new(0, 10, 0, 10)
        Frame.BorderSizePixel = 0
        Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        Frame.Parent = frame
        Frame.BackgroundTransparency = 1
        Frame.Text = ""

        local resizing = false
        local start_size
     local start
        local og_size = frame.Size

        Frame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                resizing = true
                start = input.Position
                start_size = frame.Size
          end
        end)

        Frame.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                resizing = false
            end
        end)

        library:connection(game:GetService("UserInputService").InputChanged, function(input, game_event)
   if resizing and input.UserInputType == Enum.UserInputType.MouseMovement then
                local viewport_x = workspace.CurrentCamera.ViewportSize.X
                local viewport_y = workspace.CurrentCamera.ViewportSize.Y

                local current_size = UDim2.new(
                    start_size.X.Scale,
      math.clamp(
                        start_size.X.Offset + (input.Position.X - start.X),
                        og_size.X.Offset,
                        viewport_x
                  ),
                    start_size.Y.Scale,
                    math.clamp(
                        start_size.Y.Offset + (input.Position.Y - start.Y),
                        og_size.Y.Offset,
                      viewport_y
                    )
                )

                -- library:tween(frame, {Size = current_size}, Enum.EasingStyle.Linear, 0.05) -- nobody will ntoice this aswell ðŸ‘¿
                frame.Size = current_size
            end
        end)
    end

    function library:mouse_in_frame(uiobject)
        local mouse = game:GetService("UserInputService"):GetMouseLocation()
        local guiInset = game:GetService("GuiService"):GetGuiInset().Y
        local absPos = uiobject.AbsolutePosition
        local absSize = uiobject.AbsoluteSize
        local y_cond = mouse.Y >= absPos.Y and mouse.Y <= absPos.Y + absSize.Y
        local x_cond = mouse.X >= absPos.X and mouse.X <= absPos.X + absSize.X

        return (y_cond and x_cond)
    end


    function library:draggify(frame)
        local dragging = false
        local start_pos = frame.AbsolutePosition
        local start_mouse

        frame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                start_mouse = input.Position
                start_pos = frame.AbsolutePosition
            end
        end)

        frame.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end)

        library:connection(game:GetService("UserInputService").InputChanged, function(input, game_event)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local viewport_x = workspace.CurrentCamera.ViewportSize.X
                local viewport_y = workspace.CurrentCamera.ViewportSize.Y
                local guiInsetY = game:GetService("GuiService"):GetGuiInset().Y -- Account for top bar inset

                local delta = input.Position - start_mouse
                local new_pos_x = math.clamp(start_pos.X + delta.X, 0, viewport_x - frame.AbsoluteSize.X)
                local new_pos_y = math.clamp(start_pos.Y + delta.Y - guiInsetY, 0, viewport_y - frame.AbsoluteSize.Y - guiInsetY) -- Adjust for inset

                frame.Position = UDim2.fromOffset(new_pos_x, new_pos_y + guiInsetY) -- Add inset back for final position
                library:close_current_element(nil)
            end
        end)
    end


    function library:convert(str)
        local values = {}

        for value in string.gmatch(str, "[^,]+") do
            table.insert(values, tonumber(value))
        end

        if #values == 4 then
            return unpack(values)
        else
            return
        end
    end

    function library:convert_enum(enum)
        local enum_parts = {}

        for part in string.gmatch(enum, "[%w_]+") do
            table.insert(enum_parts, part)
        end

        local enum_table = Enum
        for i = 2, #enum_parts do
            local enum_item = enum_table[enum_parts[i]]
             if not enum_item then return nil end -- Return nil if path invalid
            enum_table = enum_item
         end

        return enum_table
    end


    local config_holder;
 function library:update_config_list()
        if not config_holder then
            return
        end

        local list = {}

        for idx, file in listfiles("syphon" .. "/configs") do
            local name = file:gsub("syphon" .. "/configs\\", ""):gsub(".cfg", ""):gsub("syphon" .. "\\configs\\", "")
           list[#list + 1] = name
        end
         if #list == 0 then table.insert(list, "") end -- Add empty option if no configs found

        config_holder.refresh_options(list)
    end

    function library:get_config()
        local Config = {}

        for flag_name, v in pairs(flags) do -- Use pairs for dictionary
            if type(v) == "table" and v.key then
        Config[flag_name] = {active = v.active, mode = v.mode, key = tostring(v.key)}
            elseif type(v) == "table" and v.Color and v.Transparency ~= nil then -- Check Color and Transparency specifically
                Config[flag_name] = {Transparency = v.Transparency, Color = v.Color:ToHex()}
            else
                Config[flag_name] = v
         end
        end

        return game:GetService("HttpService"):JSONEncode(Config)
    end

    function library:load_config(config_json)
        local success, config = pcall(game.HttpService.JSONDecode, game:GetService("HttpService"), config_json)
        if not success or type(config) ~= "table" then
             library:Notify({name = "Error decoding config JSON.", color = Color3.fromRGB(255,0,0)})
             return
         end


        for flag_name, v in pairs(config) do
            local function_set = library.config_flags[flag_name]


           if flag_name == "config_name_list" then
                continue
            end

            if function_set then
                 local set_success, set_err = pcall(function()
                     if type(v) == "table" and v.Color and v.Transparency ~= nil then
                         function_set(Color3.fromHex(v.Color), v.Transparency)
                     elseif type(v) == "table" and (v.active ~= nil or v.key or v.mode) then -- Check for keybind table structure
                         function_set(v)
                     else
                         function_set(v)
                     end
                 end)
                 if not set_success then
                     warn("Error setting config flag '" .. flag_name .. "': " .. set_err)
                     -- Optionally notify the user about the specific flag error
                 end
             else
                 -- warn("Config flag '" .. flag_name .. "' not found in UI.")
             end
        end
    end


    function library:round(number, float)
        local multiplier = 1 / (float or 1)

        return math.floor(number * multiplier + 0.5) / multiplier
    end

    function library:connection(signal, callback)
        local connection = signal:Connect(callback)

      table.insert(library.connections, connection)

        return connection
    end

    function library:close_current_element(cfg)
        local path = library.current

        if path and path ~= cfg then
            path.set_visible(false)
            path.open = false
            library.current = nil -- Reset current
        end
    end


    function library:create(instance, options)
       local ins = Instance.new(instance)

        for prop, value in pairs(options) do -- Use pairs for dictionary
             pcall(function() ins[prop] = value end) -- Wrap in pcall for safety
        end

        return ins
    end


    function library:unload_menu()
        if library[ "items" ] then
        library[ "items" ]:Destroy()
         library[ "items" ] = nil
        end

        if library[ "other" ] then
            library[ "other" ]:Destroy()
            library[ "other" ] = nil
        end


        for index, connection in ipairs(library.connections) do -- Use ipairs for array
            connection:Disconnect()
        end
         library.connections = {}


        library = nil
         getgenv().library = nil -- Clear from environment too
         collectgarbage() -- Suggest garbage collection
    end

end

do -- Library element functions
    function library:Window(properties)
        local cfg = {
            -- Properties
            name = properties.name or properties.Name or "nebula";
 size = properties.size or properties.Size or UDim2.new(0, 650, 0, 400);
            logo = properties.logo or properties.Logo or "rbxassetid://128155293790451";

            selected_tab = nil; -- Initialize selected_tab
 items = {};
            tween;
        }

        library[ "items" ] = library:create( "ScreenGui" , {
            Parent = cloneref(game:GetService("CoreGui"));
            Name = "\0_MainLib";
            Enabled = true;
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
            IgnoreGuiInset = true;
            DisplayOrder = 998; -- Below notifications
         });

        library[ "other" ] = library:create( "ScreenGui" , {
            Parent = cloneref(game:GetService("CoreGui"));
            Name = "\0_Popups";
            Enabled = false; -- Only enable when a popup is open
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
            IgnoreGuiInset = true;
            DisplayOrder = 999; -- Above main UI
        });
 local items = cfg.items; do
            items[ "window" ] = library:create( "Frame" , {
                Parent = library.items;
                Name = "\0_WindowFrame";
                Position = UDim2.new(0.5, -cfg.size.X.Offset / 2, 0.5, -cfg.size.Y.Offset / 2);
 BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = cfg.size;
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });
 -- Set position based on absolute position AFTER parenting to ensure correct calculation
 task.wait() -- Wait a frame for absolute position to update
 items[ "window" ].Position = UDim2.new(0, items[ "window" ].AbsolutePosition.X, 0, items[ "window" ].AbsolutePosition.Y)

            items[ "top_frame" ] = library:create( "Frame" , {
                Name = "\0_TopBar";
                Parent = items[ "window" ];
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, 0, 0, 45);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });
 items[ "logo" ] = library:create( "ImageLabel" , {
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Parent = items[ "top_frame" ];
                Name = "\0_Logo";
                Image = cfg.logo;
                BackgroundTransparency = 1;
                Position = UDim2.new(0, 16, 0, 7);
                Size = UDim2.new(0, 32, 0, 32);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });
 items[ "ui_title" ] = library:create( "TextLabel" , {
                FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json", Enum.FontWeight.SemiBold, Enum.FontStyle.Normal);
                TextColor3 = Color3.fromRGB(255, 255, 255);
                TextStrokeColor3 = Color3.fromRGB(255, 255, 255);
                Text = cfg.name;
  Parent = items[ "top_frame" ];
                Name = "\0_Title";
                BackgroundTransparency = 1;
                Size = UDim2.new(1, -50, 1, 0); -- Leave space for logo etc.
                 Position = UDim2.new(0, 50, 0, 0); -- Position after logo
                 TextXAlignment = Enum.TextXAlignment.Left;
                 TextYAlignment = Enum.TextYAlignment.Center;
                BorderSizePixel = 0;
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                TextSize = 20; -- Adjust size
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });

            --[[ GEMINI MODIFICATION START: Adjust layout for top tabs ]]
            items[ "tab_area_outline" ] = library:create( "Frame" , {
                Parent = items[ "window" ];
                Name = "\0_TabAreaOutline";
                Position = UDim2.new(0, 0, 0, 44); -- Position below top_frame
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, 0, 0, 40); -- Height for tabs
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });

            items[ "tab_button_holder" ] = library:create( "Frame" , {
                Parent = items[ "tab_area_outline" ];
                Name = "\0_TabButtonHolder";
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, -2, 1, -2); -- Fill tab area
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(14, 14, 14); -- Match original inline color
                ClipsDescendants = true;
            });

            library:create( "UIListLayout" , {
                Parent = items[ "tab_button_holder" ];
                Padding = UDim.new(0, 5); -- Adjust padding as needed
                FillDirection = Enum.FillDirection.Horizontal; -- Arrange tabs horizontally
                VerticalAlignment = Enum.VerticalAlignment.Center; -- Center items vertically
                SortOrder = Enum.SortOrder.LayoutOrder
            });

            items[ "page_holder" ] = library:create( "Frame" , {
                Parent = items[ "window" ];
                Name = "\0_PageHolder";
                Position = UDim2.new(0, 0, 0, 84); -- Position below tab area (45 + 40 - 1 for overlap)
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, 0, 1, -84); -- Fill remaining space
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(12, 12, 12)
            });
             --[[ GEMINI MODIFICATION END ]]

             --[[ ORIGINAL CODE COMMENTED OUT
 items[ "inline" ] = library:create( "Frame" , { ... });
 items[ "tab_button_holder" ] = library:create( "Frame" , { ... });
 library:create( "UIPadding" , { ... });
 library:create( "UIListLayout" , { ... });
 items[ "page_holder" ] = library:create( "Frame" , { ... });
             ]]--
 end

        do -- Other
            library:draggify(items[ "top_frame" ]) -- Drag only by top bar
            -- library:resizify(items[ "window" ]) -- Resizing disabled for simplicity, can be re-enabled
        end

        function cfg.toggle_menu(bool)
            items.window.Visible = bool
        end

  return setmetatable(cfg, library)
    end

    function library:Page(properties)
        local cfg = {
            -- properties
            name = properties.name or properties.Name or "visuals";
 icon = properties.icon or properties.Icon or "http://www.roblox.com/asset/?id=6034767608"; -- Icon is now less relevant with top tabs

            items = {};
 }

        local items = cfg.items;
 do
            -- Tab buttons
                items[ "tab_button" ] = library:create( "TextButton" , {
                    Parent = self.items[ "tab_button_holder" ];
                    BackgroundTransparency = 0; -- Make background visible for gradient
                    Text = cfg.name; -- Use name for tab text
                    FontFace = library.font; -- Use library font
                    TextSize = 12; -- Adjust size as needed
                    TextColor3 = Color3.fromRGB(178, 178, 178); -- Default text color
                    Size = UDim2.new(0, 0, 1, -4); -- Fill height minus padding, auto width
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    BorderSizePixel = 1; -- Add border for definition
                    AutomaticSize = Enum.AutomaticSize.X; -- Auto size based on text
                    BackgroundColor3 = Color3.fromRGB(14, 14, 14); -- Base color (will be overlayed by gradient)
                    AutoButtonColor = false;
                    Name = cfg.name .. "_TabButton"; -- Descriptive name
                });

                --[[ GEMINI MODIFICATION START: Apply fade gradient to tab button ]]
                 library:create( "UIGradient" , {
                    Rotation = 90;
                    Parent = items[ "tab_button" ];
                    Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(33, 33, 33)), ColorSequenceKeypoint.new(1, Color3.fromRGB(8, 8, 8))}
                });
                --[[ GEMINI MODIFICATION END ]]

                library:create("UIPadding", { -- Add padding inside the button
                    Parent = items["tab_button"];
                    PaddingLeft = UDim.new(0, 8);
                    PaddingRight = UDim.new(0, 8);
                });

                --[[ ORIGINAL CODE COMMENTED/MODIFIED OUT
 Text = "";
                    Size = UDim2.new(1, 0, 0, 0);
 AutomaticSize = Enum.AutomaticSize.Y;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                });
 items[ "image" ] = library:create( "ImageLabel" , { ... });
                ]]--
 --

            -- Page directory
                items[ "tab" ] = library:create( "Frame" , {
                    Parent = library.items; -- Initially parented here, moved later
                    BackgroundTransparency = 1;
   Name = cfg.name .. "_PageFrame"; -- Descriptive name
                    Visible = false;
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(1, 0, 1, 0);
                    BorderSizePixel = 0;
                 BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                });
 library:create( "UIListLayout" , {
                    FillDirection = Enum.FillDirection.Horizontal;
                    HorizontalFlex = Enum.UIFlexAlignment.SpaceAround; -- Changed flex alignment
                    Parent = items[ "tab" ];
                    Padding = UDim.new(0, 21);
              SortOrder = Enum.SortOrder.LayoutOrder;
                    VerticalFlex = Enum.UIFlexAlignment.Fill
                });
 library:create( "UIPadding" , {
                    PaddingTop = UDim.new(0, 24);
                    PaddingBottom = UDim.new(0, 21);
                    Parent = items[ "tab" ];
                    PaddingRight = UDim.new(0, 21);
                PaddingLeft = UDim.new(0, 21)
                });
 for _,column in ipairs({"left", "right"}) do -- Use ipairs
                    items[ column ] = library:create( "Frame" , {
                        Parent = items[ "tab" ];
                        BackgroundTransparency = 1;
            Name = "\0_" .. column .. "Column"; -- Descriptive name
                        BorderColor3 = Color3.fromRGB(0, 0, 0);
                        Size = UDim2.new(0.48, 0, 1, 0); -- Adjust size for horizontal layout
                        BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(8, 8, 8)
                    });

                    -- Add list layout to columns for vertical arrangement of sections
                    library:create( "UIListLayout" , {
                        Parent = items[ column ];
                        Padding = UDim.new(0, 10); -- Padding between sections
                        SortOrder = Enum.SortOrder.LayoutOrder
                    });
 end
            --
        end

        function cfg.open_tab()
            local selected_tab_button = self.selected_tab and self.selected_tab[1]
            local selected_tab_page = self.selected_tab and self.selected_tab[2]

            if selected_tab_button and selected_tab_page then
                -- Deselect previous tab
                if selected_tab_button.Parent then -- Check if still valid
                     library:tween(selected_tab_button, {TextColor3 = Color3.fromRGB(178, 178, 178)}, Enum.EasingStyle.Quad, 0.1)
                     selected_tab_button.BorderSizePixel = 1 -- Reset border
                     selected_tab_button.ZIndex = 1 -- Reset ZIndex
                 end
                 if selected_tab_page.Parent then -- Check if still valid
                    selected_tab_page.Parent = library.items -- Move page back
                    selected_tab_page.Visible = false
                 end
            end


            -- Select new tab
            library:tween(items.tab_button, {TextColor3 = Color3.fromRGB(255, 255, 255)}, Enum.EasingStyle.Quad, 0.1)
            items.tab_button.BorderSizePixel = 0 -- Remove border for selected tab feel
            items.tab_button.ZIndex = 2 -- Bring selected tab forward slightly
   items.tab.Parent = self.items[ "page_holder" ]
            items.tab.Visible = true

            self.selected_tab = {
                items.tab_button; -- Store button instead of image
 items.tab;
            }

            library:close_current_element(nil)
        end


        items[ "tab_button" ].MouseButton1Down:Connect(function()
            cfg.open_tab()
        end)

        if not self.selected_tab then
            cfg.open_tab() -- Call without true, as it's the first tab
        end


        return setmetatable(cfg, library)
    end


   function library:Section(properties)
        local cfg = {
            name = properties.name or properties.Name or "section";
 side = properties.side or properties.Side or "left";
            default = properties.default or properties.Default or false; -- Seems unused
-- size = properties.size or properties.Size or 0.5; -- Size might need adjustment depending on layout
            icon = properties.icon or properties.Icon or "http://www.roblox.com/asset/?id=6022668898"; -- Unused visually
 fading_toggle = properties.fading or properties.Fading or false; -- Seems unused
            items = {};
        };

        local items = cfg.items;
 do
            items[ "section_outline" ] = library:create( "Frame" , {
                Name = cfg.name .. "_SectionOutline";
                Parent = self.items[ cfg.side ];
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, 0, 0, 0); -- Width 100%, auto height
                AutomaticSize = Enum.AutomaticSize.Y; -- Auto size based on content
               BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(8, 8, 8)
            });
 items[ "section_shadow" ] = library:create( "Frame" , {
                Parent = items[ "section_outline" ];
                Name = "\0_Shadow1";
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
  Size = UDim2.new(1, -2, 1, -2);
                 AutomaticSize = Enum.AutomaticSize.Y; -- Auto size
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(5, 5, 5)
            });
 items[ "section_shadow_one" ] = library:create( "Frame" , {
                Parent = items[ "section_shadow" ];
                Name = "\0_Shadow2";
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
  Size = UDim2.new(1, -2, 1, -2);
                 AutomaticSize = Enum.AutomaticSize.Y; -- Auto size
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });
 items[ "section_shadow_two" ] = library:create( "Frame" , {
                Parent = items[ "section_shadow_one" ];
                Name = "\0_Shadow3";
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
  Size = UDim2.new(1, -2, 1, -2);
                 AutomaticSize = Enum.AutomaticSize.Y; -- Auto size
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });
 items[ "section_shadow_three" ] = library:create( "Frame" , {
                Name = "\0_ContentBg";
                Parent = items[ "section_shadow_two" ];
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, 0, 1, 0); -- Use full width
                 AutomaticSize = Enum.AutomaticSize.Y; -- Auto size
  BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(14, 14, 14)
            });
 library:create( "UICorner" , {
                Parent = items[ "section_shadow_three" ];
                CornerRadius = UDim.new(0, 0)
            });

            -- [[ GEMINI MODIFICATION START: Use Frame + UIListLayout instead of ScrollingFrame for sections ]]
            items[ "elements" ] = library:create( "Frame" , {
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Parent = items[ "section_shadow_three" ]; -- Parent to the main section background
                Name = "\0_ElementsContainer";
                BackgroundTransparency = 1;
                Position = UDim2.new(0, 0, 0, 0); -- Reset position
                Size = UDim2.new(1, 0, 0, 0); -- Full width, auto height
                BorderSizePixel = 0;
                AutomaticSize = Enum.AutomaticSize.Y;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });
             library:create( "UIPadding" , { -- Padding for elements within the section
                Parent = items[ "elements" ];
                PaddingTop = UDim.new(0, 12);
                PaddingBottom = UDim.new(0, 12);
                PaddingLeft = UDim.new(0, 12);
                PaddingRight = UDim.new(0, 12);
            });
            --[[ GEMINI MODIFICATION END ]]

 library:create( "UIListLayout" , {
                Parent = items[ "elements" ];
                Padding = UDim.new(0, 5);
                SortOrder = Enum.SortOrder.LayoutOrder
            });
 library:create( "UICorner" , {
                Parent = items[ "section_shadow_two" ];
                CornerRadius = UDim.new(0, 0)
            });
 library:create( "UICorner" , {
                Parent = items[ "section_shadow_one" ];
                CornerRadius = UDim.new(0, 0)
            });
 library:create( "UICorner" , {
                Parent = items[ "section_shadow" ];
                CornerRadius = UDim.new(0, 0)
            });
 items["SectionTitle"] = library:create( "TextLabel" , { -- Store reference to title
                FontFace = library.font;
                TextColor3 = Color3.fromRGB(255, 255, 255);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Text = cfg.name;
                Parent = items[ "section_outline" ];
                BackgroundTransparency = 1;
                Position = UDim2.new(0, 8, 0, -15);
                BorderSizePixel = 0;
                AutomaticSize = Enum.AutomaticSize.XY;
                TextSize = 10;
        BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                 Name = cfg.name .. "_SectionTitle"; -- Descriptive name
            });
 library:create( "UIStroke" , {
                Parent = items[ "SectionTitle" ] -- Apply to title reference
            });
 library:create( "UICorner" , {
                Parent = items[ "section_outline" ];
                CornerRadius = UDim.new(0, 0)
            });
 end;

        items[ "section_outline" ].MouseEnter:Connect(function()
            for _,instance in items[ "section_outline" ]:GetDescendants() do
                if instance:IsA("UICorner") then
                    library:tween(instance, {CornerRadius = UDim.new(0, 8)})
                end
            end
   end)

        items[ "section_outline" ].MouseLeave:Connect(function()
            for _,instance in items[ "section_outline" ]:GetDescendants() do
                if instance:IsA("UICorner") then
                    library:tween(instance, {CornerRadius = UDim.new(0, 0)})
                end
         end
        end)

        return setmetatable(cfg, library)
    end


    -- Continue with the rest of the elements (Toggle, Slider, Dropdown, etc.)
    -- Ensure correct parenting (self.items.elements) and layout adjustments as needed.

    function library:Toggle(options)
        local cfg = {
            enabled = options.enabled or options.Enabled or nil,
            name = options.name or options.Name or "Toggle",
            flag = options.flag or options.Flag or options.name or options.Name or "NO FLAG FOUND BUGGED FOR CONFIG",

            default = options.default or options.Default or false,
            callback = options.callback or options.Callback or function() end,

            items = {};
 }

        local items = cfg.items;
 do
            items[ "object" ] = library:create( "TextButton" , {
                Parent = self.items[ "elements" ];
                Text = "";
                Name = cfg.name .. "_ToggleObject";
                BackgroundTransparency = 1;
          Size = UDim2.new(1, 0, 0, 12);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                BorderSizePixel = 0;
                -- AutomaticSize = Enum.AutomaticSize.Y;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                AutoButtonColor = false;
        });

            items[ "toggle_outline" ] = library:create( "Frame" , {
                Parent = items[ "object" ];
                BackgroundTransparency = 1;
                Name = "\0_ToggleOutline";
                BorderColor3 = Color3.fromRGB(0, 0, 0);
    Size = UDim2.new(0, 12, 0, 12);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });
 items[ "toggle_shading" ] = library:create( "Frame" , {
                Parent = items[ "toggle_outline" ];
                Name = "\0_ToggleShading";
                BackgroundTransparency = 1;
                Position = UDim2.new(0, 1, 0, 1);
 BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, -2, 1, -2);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(92, 92, 92)
            });
 items[ "toggle_inline" ] = library:create( "Frame" , {
                Parent = items[ "toggle_shading" ];
                Name = "\0_ToggleInline";
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
  Size = UDim2.new(1, -2, 1, -2);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(54, 54, 54)
            });
 library:create( "UIListLayout" , {
                Parent = items[ "object" ];
                Padding = UDim.new(0, 5);
                SortOrder = Enum.SortOrder.LayoutOrder;
                FillDirection = Enum.FillDirection.Horizontal;
                VerticalAlignment = Enum.VerticalAlignment.Center; -- Center vertically
            });
 items[ "text" ] = library:create( "TextLabel" , {
                FontFace = library.font;
                TextColor3 = Color3.fromRGB(178, 178, 178);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Text = cfg.name;
                Parent = items[ "object" ];
                 Name = cfg.name .. "_ToggleLabel";
                BackgroundTransparency = 1;
                -- Position = UDim2.new(0, 12, 0, 0); -- Position managed by layout
                BorderSizePixel = 0;
                Size = UDim2.new(1, -17, 1, 0); -- Fill width minus toggle and padding
                TextXAlignment = Enum.TextXAlignment.Left; -- Align left
                -- AutomaticSize = Enum.AutomaticSize.XY; -- Size managed by layout
                TextSize = 10;
            BackgroundColor3 = Color3.fromRGB(255, 255, 255);
             LayoutOrder = 1; -- Ensure label is first visually
            });
 library:create( "UIStroke" , {
                Parent = items[ "text" ]
            });
            items["toggle_outline"].LayoutOrder = 2; -- Ensure toggle is second
 end;

        function cfg.set(bool)
             if type(bool) ~= "boolean" then return end -- Type check

            library:tween(items[ "text" ], {TextColor3 = bool and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(178, 178, 178)})
            library:tween(items[ "toggle_outline" ], {BackgroundTransparency = bool and 0 or 1})
            library:tween(items[ "toggle_shading" ], {BackgroundTransparency = bool and 0 or 1})
            library:tween(items[ "toggle_inline" ], {BackgroundColor3 = bool and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(74, 74, 74)})

            if flags[cfg.flag] ~= bool then -- Only call callback if value changed
                flags[cfg.flag] = bool
                 pcall(cfg.callback, bool) -- Wrap callback in pcall
            end
        end


        items[ "object" ].MouseButton1Click:Connect(function()
            cfg.enabled = not cfg.enabled
            cfg.set(cfg.enabled)
        end)

        flags[cfg.flag] = cfg.default -- Initialize flag
        cfg.set(cfg.default) -- Set initial state without triggering callback necessarily


       config_flags[cfg.flag] = cfg.set

        return setmetatable(cfg, library)
    end

    function library:Slider(options)
        local cfg = {
            -- Options
            name = options.name or options.Name or nil;
 suffix = options.suffix or options.Suffix or "";
            flag = options.flag or options.Flag or options.name or options.Name or "please set me a flag ðŸ¥º";
 callback = options.callback or options.Callback or function() end;
            show_value = options.ShowValue or options.show_value or true;
 -- value settings
            min = options.min or options.minimum or options.Min or options.Minimum or 0;
 max = options.max or options.maximum or options.Max or options.Maximum or 100;
 intervals = options.interval or options.decimal or options.Interval or options.Decimal or 1;
            default = options.default or options.Default or options.min or 0; -- Default to min if not specified
 value = options.default or options.Default or options.min or 0; -- Default to min if not specified

            -- ignore
            dragging = false;
 items = {}
        }

        local items = cfg.items;
 do
            items[ "object" ] = library:create( "Frame" , {
                Parent = self.items.object or self.items.elements;
                Name = cfg.name .. "_SliderObject";
                BackgroundTransparency = 1;
                Size = UDim2.new(1, 0, 0, 12); -- Full width, fixed height
            BorderColor3 = Color3.fromRGB(0, 0, 0);
                BorderSizePixel = 0;
                -- AutomaticSize = Enum.AutomaticSize.XY; -- Use fixed size
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });
 library:create( "UIListLayout" , {
                Parent = items[ "object" ];
                Padding = UDim.new(0, 5);
                SortOrder = Enum.SortOrder.LayoutOrder;
                FillDirection = Enum.FillDirection.Horizontal;
                VerticalAlignment = Enum.VerticalAlignment.Center;
            });
 items[ "slider_parent" ] = library:create( "TextButton" , {
                Parent = items[ "object" ];
                BackgroundTransparency = 1;
                Text = "";
                Name = "\0_SliderParent";
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(0, 100, 1, 0); -- Fixed width slider bar
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                AutoButtonColor = false;
                 LayoutOrder = 2; -- Place slider after labels
            });
 items[ "slider_holder" ] = library:create( "Frame" , {
                AnchorPoint = Vector2.new(0, 0.5);
                Parent = items[ "slider_parent" ];
                Name = "\0_SliderHolder";
                Position = UDim2.new(0, 0, 0.5, 0);
  BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, 0, 0, 5);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });
 items[ "gradient_holder" ] = library:create( "Frame" , {
                Parent = items[ "slider_holder" ];
                Name = "\0_SliderGradientHolder";
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
  Size = UDim2.new(1, -2, 1, -2);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });
 library:create( "UIGradient" , {
                Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)), ColorSequenceKeypoint.new(1, Color3.fromRGB(93, 93, 93))};
                Parent = items[ "gradient_holder" ]
            });
 items[ "slider" ] = library:create( "Frame" , {
                AnchorPoint = Vector2.new(0.5, 0.5); -- Center anchor point
                Parent = items[ "gradient_holder" ];
                Name = "\0_SliderHandle";
                Position = UDim2.new(0, 0, 0.5, 0);
  BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(0, 4, 0, 9);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(0, 0, 0);
                 ZIndex = 3; -- Above gradient
            });
 items[ "inline" ] = library:create( "Frame" , {
                Parent = items[ "slider" ];
                Name = "\0_SliderHandleInline";
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
  Size = UDim2.new(1, -2, 1, -2);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });

             -- Create label frame to handle layout better
            items[ "label_frame" ] = library:create( "Frame" , {
                Parent = items[ "object" ];
                Name = cfg.name .. "_SliderLabelFrame";
                BackgroundTransparency = 1;
                Size = UDim2.new(1, -105, 1, 0); -- Fill remaining space
                AutomaticSize = Enum.AutomaticSize.None;
                 LayoutOrder = 1; -- Place labels before slider
            });

            library:create( "UIListLayout" , {
                Parent = items[ "label_frame" ];
                Padding = UDim.new(0, 5);
                SortOrder = Enum.SortOrder.LayoutOrder;
                FillDirection = Enum.FillDirection.Horizontal;
                VerticalAlignment = Enum.VerticalAlignment.Center;
                HorizontalAlignment = Enum.HorizontalAlignment.Left; -- Align labels left
            });

 if cfg.name then
                items[ "name_label" ] = setmetatable(cfg, library):Label({name = cfg.name, parent = items.label_frame}) -- Pass parent
            end

            if cfg.show_value then
                items[ "value_label" ] = setmetatable(cfg, library):Label({name = "", parent = items.label_frame}) -- Pass parent, start empty
            end
   end

        function cfg.set(value)
             if type(value) ~= "number" then return end -- Type check

            local old_value = flags[cfg.flag]
            local rounded_value = library:round(value, cfg.intervals)
            cfg.value = math.clamp(rounded_value, cfg.min, cfg.max)


            local percentage = (cfg.value - cfg.min) / (cfg.max - cfg.min)
            if (cfg.max - cfg.min) == 0 then percentage = 0 end -- Avoid division by zero
            items[ "slider" ].Position = UDim2.new(percentage, 0, 0.5, 0)


            if items[ "value_label" ] then
                items[ "value_label" ].set(tostring(cfg.value) .. cfg.suffix)
            end


            if flags[cfg.flag] ~= cfg.value then -- Only call callback if value changed
                flags[cfg.flag] = cfg.value
                 pcall(cfg.callback, flags[cfg.flag]) -- Wrap callback in pcall
            end
        end


        items[ "slider_parent" ].MouseButton1Down:Connect(function()
            cfg.dragging = true
             local mouseX = game:GetService("UserInputService"):GetMouseLocation().X
             local sliderX = items[ "gradient_holder" ].AbsolutePosition.X
             local sliderWidth = items[ "gradient_holder" ].AbsoluteSize.X
             local percentage = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
             local value = ((cfg.max - cfg.min) * percentage) + cfg.min
             cfg.set(value) -- Initial set on click
        end)


        library:connection(game:GetService("UserInputService").InputChanged, function(input)
   if cfg.dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local mouseX = input.Position.X
                 local sliderX = items[ "gradient_holder" ].AbsolutePosition.X
                 local sliderWidth = items[ "gradient_holder" ].AbsoluteSize.X
                 local percentage = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                 local value = ((cfg.max - cfg.min) * percentage) + cfg.min
                 cfg.set(value)
            end
        end)

     library:connection(game:GetService("UserInputService").InputEnded, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                cfg.dragging = false
            end
        end)

        flags[cfg.flag] = cfg.default -- Initialize flag
        cfg.set(cfg.default) -- Set initial state
        config_flags[cfg.flag] = cfg.set


        return setmetatable(cfg, library)
  end

    function library:Dropdown(options)
        local cfg = {
            obj_type = "dropdown";
 -- Options
            name = options.name or options.Name or nil;
 flag = options.flag or options.Flag or options.name or options.Name or "please set me a flag ðŸ¥º";
 options = options.items or options.Items or options.Options or {""}; -- Default to empty option
            callback = options.callback or options.Callback or function() end;
 multi = options.multi or options.Multi or false;

            -- Ignore these
            open = false;
 option_instances = {};
            multi_items = {};
            items = {};
        }


        cfg.default = options.default or options.Default or (cfg.multi and {cfg.options[1]}) or cfg.options[1] or "" -- Use first option or empty string
        flags[cfg.flag] = cfg.default


        local items = cfg.items;
 do
            -- Element
                items[ "object" ] = library:create( "Frame" , {
                    Parent = self.items.object or self.items.elements;
                    Name = cfg.name .. "_DropdownObject";
   BackgroundTransparency = 1;
                    Size = UDim2.new(1, 0, 0, 16); -- Full width, fixed height
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    BorderSizePixel = 0;
                   -- AutomaticSize = Enum.AutomaticSize.XY; -- Use fixed size
                  BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                });
 --[[ if self.items.object then ... end ]]--


                 library:create( "UIListLayout" , { -- Add layout to main object
                    Parent = items[ "object" ];
                    Padding = UDim.new(0, 5);
                    SortOrder = Enum.SortOrder.LayoutOrder;
                    FillDirection = Enum.FillDirection.Horizontal;
                    VerticalAlignment = Enum.VerticalAlignment.Center;
                });


                 -- Create label frame for dropdown name
                items[ "label_frame" ] = library:create( "Frame" , {
                    Parent = items[ "object" ];
                    Name = cfg.name .. "_DropdownLabelFrame";
                    BackgroundTransparency = 1;
                    Size = UDim2.new(0.5, -5, 1, 0); -- Adjust size as needed
                     LayoutOrder = 1; -- Label first
                });
                if cfg.name then
                     local labelText = library:create( "TextLabel" , {
                        FontFace = library.font;
                        TextColor3 = Color3.fromRGB(178, 178, 178);
                        BorderColor3 = Color3.fromRGB(0, 0, 0);
                        Text = cfg.name;
                        Parent = items[ "label_frame" ];
                        Name = cfg.name .. "_DropdownLabel";
                        BackgroundTransparency = 1;
                        Size = UDim2.new(1, 0, 1, 0);
                        BorderSizePixel = 0;
                        TextXAlignment = Enum.TextXAlignment.Left;
                        TextYAlignment = Enum.TextYAlignment.Center;
                        TextSize = 10;
                        BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    });
                     library:create( "UIStroke" , { Parent = labelText });
                end



                items[ "dropdown_outline" ] = library:create( "TextButton" , {
                    Parent = items[ "object" ];
                    Text = "";
        AutoButtonColor = false;
                    Name = "\0_DropdownOutline";
                    Size = UDim2.new(0.5, 0, 1, 0); -- Adjust size
                    BorderSizePixel = 1; -- Add border
 -- AutomaticSize = Enum.AutomaticSize.X;
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0);
                    LayoutOrder = 2; -- Ensure it appears after label frame
                });
 items[ "dropdown_shading_inner" ] = library:create( "Frame" , { -- Renamed to avoid conflict
                    Parent = items[ "dropdown_outline" ];
                    Size = UDim2.new(1, -2, 1, -2); -- Fill inner area
                    Name = "\0_DropdownShadingInner";
                    Position = UDim2.new(0, 1, 0, 1);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    BorderSizePixel = 0;
                    -- AutomaticSize = Enum.AutomaticSize.X;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                    ClipsDescendants = true; -- Clip text and arrow
           });
 -- Desktop leaked this


                library:create( "UIGradient" , {
                    Rotation = 90;
                    Parent = items[ "dropdown_shading_inner" ]; -- Apply to inner frame
    Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(33, 33, 33)), ColorSequenceKeypoint.new(1, Color3.fromRGB(8, 8, 8))}
                });
 items.inner_text = library:create( "TextLabel" , {
                    FontFace = library.font;
                    TextColor3 = Color3.fromRGB(178, 178, 178);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Text = "Select..."; -- Placeholder text
                 Parent = items[ "dropdown_shading_inner" ]; -- Parent to inner frame
                     Name = "\0_DropdownSelectedText";
                    AnchorPoint = Vector2.new(0, 0.5);
                    Size = UDim2.new(1, -15, 1, 0); -- Adjust size for arrow
                    BackgroundTransparency = 1;
           Position = UDim2.new(0, 5, 0.5, 0); -- Add left padding
                    BorderSizePixel = 0;
                   -- AutomaticSize = Enum.AutomaticSize.XY;
                    TextXAlignment = Enum.TextXAlignment.Left;
                    TextSize = 10;
                  BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                });
 library:create( "UIStroke" , {
                    Parent = items.inner_text -- Apply stroke to inner text
                });
--[[ ... padding removal ... ]]--
 items[ "arrow" ] = library:create( "ImageLabel" , {
                    ImageColor3 = Color3.fromRGB(178, 178, 178);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Parent = items[ "dropdown_shading_inner" ]; -- Parent to inner frame
                    Name = "\0_DropdownArrow";
                    AnchorPoint = Vector2.new(1, 0.5);
                    Image = "rbxassetid://7666721348"; -- UPDATED/VERIFIED ASSET ID FOR DOWN ARROW
                    BackgroundTransparency = 1;
                    Position = UDim2.new(1, -4, 0.5, 0);
             Size = UDim2.new(0, 7, 0, 4);
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                });
--[[ ... list layout removal ... ]]--
 --


            -- Element Holder (Popup)
                items[ "dropdown_holder" ] = library:create( "Frame" , {
                    Parent = library.other; -- Parent to the 'other' ScreenGui to draw over main UI
                    Size = UDim2.new(0, 114, 0, 0); -- Width determined dynamically, auto height
     Visible = false;
                    Name = cfg.name .. "_DropdownPopup";
                    Position = UDim2.new(0, 0, 0, 0); -- Position dynamically
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    BorderSizePixel = 1; -- Add border
                    AutomaticSize = Enum.AutomaticSize.Y;
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0);
                    ZIndex = 10; -- Ensure it's above other elements
                });
 items[ "dropdown_shading" ] = library:create( "Frame" , { -- Keep this name for options
                    Parent = items[ "dropdown_holder" ];
                    Size = UDim2.new(1, -2, 1, -2); -- Use 1, -2 for size relative to border
                    Name = "\0_DropdownPopupShading";
                    Position = UDim2.new(0, 1, 0, 1);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    BorderSizePixel = 0;
                    AutomaticSize = Enum.AutomaticSize.Y;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                    ClipsDescendants = true; -- Clip options if too many
           });
 library:create( "UIGradient" , {
                    Rotation = 90;
                    Parent = items[ "dropdown_shading" ];
                    Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(33, 33, 33)), ColorSequenceKeypoint.new(1, Color3.fromRGB(8, 8, 8))}
                });
 library:create( "UIListLayout" , {
                    Parent = items[ "dropdown_shading" ];
                    Padding = UDim.new(0, 5);
                    SortOrder = Enum.SortOrder.LayoutOrder
                });
 library:create( "UIPadding" , {
                    PaddingBottom = UDim.new(0, 5);
                    PaddingTop = UDim.new(0, 5);
                     PaddingLeft = UDim.new(0, 5); -- Add internal padding for options
                     PaddingRight = UDim.new(0, 5);
                    Parent = items[ "dropdown_shading" ]
                });
 --
        end


        function cfg.render_option(text)
            local button = library:create( "TextButton" , {
                FontFace = library.font;
                TextColor3 = Color3.fromRGB(178, 178, 178);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
            Text = text;
                Parent = items[ "dropdown_shading" ];
                 Name = tostring(text) .. "_DropdownOption";
                Size = UDim2.new(1, 0, 0, 0);
                BackgroundTransparency = 1;
                TextXAlignment = Enum.TextXAlignment.Left;
      BorderSizePixel = 0;
                AutomaticSize = Enum.AutomaticSize.Y;
                TextSize = 10;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                AutoButtonColor = false;
            });
 library:create( "UIStroke" , {
                Parent = button
            });
 --[[ library:create( "UIPadding" , { ... }); -- Padding handled by parent container ]]--
 return button
        end


        function cfg.set_visible(bool)
            if bool then
                library.other.Enabled = true -- Enable the ScreenGui holding the dropdown
                 library:close_current_element(cfg) -- Close other popups

                 -- Set width first, then wait for render before positioning
                 items.dropdown_holder.Size = UDim2.new(0, items.dropdown_outline.AbsoluteSize.X, 0, 0)
                 task.wait() -- Wait for size update

                 local popupY = items.dropdown_outline.AbsolutePosition.Y + items.dropdown_outline.AbsoluteSize.Y
                 local popupHeight = items.dropdown_holder.AbsoluteSize.Y
                 local viewportY = workspace.CurrentCamera.ViewportSize.Y
                 local guiInset = game:GetService("GuiService"):GetGuiInset().Y

                  -- Position below button, or above if not enough space below
                  if popupY + popupHeight > viewportY - guiInset then
                      items.dropdown_holder.Position = UDim2.fromOffset(items.dropdown_outline.AbsolutePosition.X, items.dropdown_outline.AbsolutePosition.Y - popupHeight)
                  else
                      items.dropdown_holder.Position = UDim2.fromOffset(items.dropdown_outline.AbsolutePosition.X, popupY)
                  end

                 items.dropdown_holder.Visible = true
                 library.current = cfg -- Set this as the current open element
            else
                 items.dropdown_holder.Visible = false
                 if library.current == cfg then library.current = nil end -- Clear current if this was it
                 library.other.Enabled = false -- Disable screen gui only if no other popups are open (needs better check)
            end
            items[ "arrow" ].Rotation = bool and 180 or 0
        end


        function cfg.set(value)
            local selected = {}
 local isTable = type(value) == "table"
             local display_text = ""


            for _, option in ipairs(cfg.option_instances) do -- Use ipairs for ordered list
                 local optionText = option.Text
                 local isSelected = (not isTable and optionText == value) or (isTable and value and table.find(value, optionText)) -- Added nil check for value


                if isSelected then
                    table.insert(selected, optionText)
                    option.TextColor3 = Color3.fromRGB(255, 255, 255)
                else
                    option.TextColor3 = Color3.fromRGB(174, 174, 174)
                end
            end


             if isTable then
                 cfg.multi_items = selected -- Update multi_items only if it's multi-select
                 display_text = table.concat(selected, ", ")
                 if #selected == 0 then display_text = "None" end -- Show 'None' if empty
                 flags[cfg.flag] = selected
             else
                 display_text = selected[1] or value or "None" -- Handle nil or empty selection
                 flags[cfg.flag] = selected[1] or value
             end

             items.inner_text.Text = display_text


            if cfg.set_called_by_user == nil then -- Avoid callback loop during init/refresh
                 pcall(cfg.callback, flags[cfg.flag]) -- Wrap callback in pcall
             end
        end



        function cfg.refresh_options(list)
             local current_value = flags[cfg.flag] -- Store current value before clearing
             cfg.set_called_by_user = false -- Prevent callback during refresh

            for _, option in ipairs(cfg.option_instances) do -- Use ipairs
           option:Destroy()
            end


            cfg.option_instances = {}
             cfg.multi_items = {} -- Reset multi items


            for _, option in ipairs(list) do -- Use ipairs
                local button = cfg.render_option(option)
    table.insert(cfg.option_instances, button)


                button.MouseButton1Down:Connect(function()
                    cfg.set_called_by_user = true -- Allow callback trigger
                    if cfg.multi then
                        local selected_index = table.find(cfg.multi_items, button.Text)


                        if selected_index then
                            table.remove(cfg.multi_items, selected_index)
                        else
                  table.insert(cfg.multi_items, button.Text)
                        end


                        cfg.set(cfg.multi_items)
            else
                        cfg.set_visible(false)
                        cfg.open = false


            cfg.set(button.Text)
                    end
                    cfg.set_called_by_user = nil -- Reset flag
                end)
            end
             cfg.set(current_value or cfg.default) -- Set to previous value or default after refreshing
             cfg.set_called_by_user = nil -- Reset flag
        end



        items.dropdown_outline.MouseButton1Click:Connect(function()
            cfg.open = not cfg.open
   cfg.set_visible(cfg.open)
        end) -- Desktop did infact leak this


        library:connection(game:GetService("UserInputService").InputEnded, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                 task.wait() -- Wait a frame to allow button clicks to register
                 if cfg.open and not (library:mouse_in_frame(items.dropdown_holder) or library:mouse_in_frame(items.dropdown_outline)) then
                    cfg.open = false
      cfg.set_visible(false)
                end
            end
        end)


        -- flags[cfg.flag] = {} -- Initialized earlier
        config_flags[cfg.flag] = cfg.set -- Use the main set function for config loading


        cfg.refresh_options(cfg.options)
        -- cfg.set(cfg.default) -- Moved to refresh_options


        local set = setmetatable(cfg, library)


--[[       if cfg.name then ... end ]]--


        return set
    end


    function library:Label(options)
        local cfg = {
            name = options.Name or options.name or "Label",
            parent = options.parent or self.items.object or self.items.elements, -- Allow specifying parent


            -- ignore
        padding_top = options.PaddingTop or options.padding_top or 0;
        padding_bottom = options.PaddingBottom or options.padding_bottom or 0; -- Corrected variable name
 items = {};
        }


        local items = cfg.items;
 do
            -- [[ GEMINI: Simplify - Create TextLabel directly, parent is handled by cfg.parent ]]
            items.text = library:create( "TextLabel" , {
                 Parent = cfg.parent;
                 Name = cfg.name .. "_Label"; -- Give it a more descriptive name
                FontFace = library.font;
                TextColor3 = Color3.fromRGB(178, 178, 178);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Text = cfg.name;
                RichText = true;
 -- Parent = items.object;
                BackgroundTransparency = 1;
               -- Position = UDim2.new(0, 12, 0, 0); -- Position handled by layout
                BorderSizePixel = 0;
                Size = UDim2.new(0, 0, 0, 10); -- Auto width/height handled by layout/size
                TextXAlignment = Enum.TextXAlignment.Left; -- Align left
                TextYAlignment = Enum.TextYAlignment.Center; -- Align center vertically
                AutomaticSize = Enum.AutomaticSize.X; -- Auto width based on text
        TextSize = 10;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });


            -- [[ ORIGINAL CODE COMMENTED OUT ... ]]--


 library:create( "UIStroke" , {
                Parent = items.text
            });
 --[[ library:create( "UIPadding" , { ... }); -- Padding handled by parent layout potentially ]]--
 end


        function cfg.set(text)
            items.text.Text = tostring(text) -- Ensure text is string
        end



        return setmetatable(cfg, library)
    end


    function library:Colorpicker(options)
        local cfg = {
            -- options
            name = options.name or options.Name or "",
            flag = options.flag or options.Flag or options.name or options.Name or "please set me a flag ðŸ¥º",
            color = options.color or options.Color or Color3.new(1, 1, 1), -- Default to white color if not provided
            alpha = (options.alpha and 1 - options.alpha) or (options.Alpha and 1 - options.Alpha) or 0, -- Keep original alpha logic (0 = opaque, 1 = transparent)
            callback = options.callback or options.Callback or function() end,


            -- ignore
            open = false,
            items = {};
 }


        local dragging_sat = false
        local dragging_hue = false
        local dragging_alpha = false


        local h, s, v = cfg.color:ToHSV()
        local a = cfg.alpha


        flags[cfg.flag] = {Color = cfg.color, Transparency = cfg.alpha}


        local items = cfg.items;
 do
             -- Main object frame for layout
             items["object"] = library:create("Frame", {
                 Parent = self.items.elements;
                 Name = cfg.name .. "_ColorPickerObject";
                 BackgroundTransparency = 1;
                 Size = UDim2.new(1, 0, 0, 12); -- Full width, fixed height
             })
             library:create("UIListLayout", {
                 Parent = items["object"];
                 FillDirection = Enum.FillDirection.Horizontal;
                 VerticalAlignment = Enum.VerticalAlignment.Center;
                 HorizontalAlignment = Enum.HorizontalAlignment.Right; -- Align button right
                 Padding = UDim.new(0, 5);
             })

             -- Label (if name provided)
             if cfg.name then
                 local label = self:Label({Name = cfg.name, parent = items.object})
                 label.items.text.LayoutOrder = 1
                 label.items.text.Size = UDim2.new(1, -17, 1, 0) -- Adjust size for button
             end

            -- Component (Gear Button) in the main element layout
                items[ "gear_holder" ] = library:create( "TextButton" , {
                    Parent = items.object; -- Parent to the list layout of the element containing this
                    AutoButtonColor = false;
  Text = "";
                    BackgroundTransparency = 1;
                    Name = "\0_ColorPickerGear";
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(0, 12, 0, 12); -- Fixed size for the gear button
                BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                    LayoutOrder = 2; -- Ensure it appears after the label
                });
 items[ "gear" ] = library:create( "ImageLabel" , {
                    ImageColor3 = Color3.fromRGB(178, 178, 178);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Parent = items[ "gear_holder" ];
                    Image = "rbxassetid://9947371938"; -- UPDATED/VERIFIED GEAR ICON ASSET ID
                    BackgroundTransparency = 1;
                    Name = "\0";
                    Size = UDim2.new(1, 0, 1, 0); -- Fill the holder
                    BorderSizePixel = 0;
            BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                });
--[[ ... padding removal ... ]]--
 --


            -- Colorpicker Popup Window
                items[ "colorpicker_outline" ] = library:create( "Frame" , {
                    Parent = library.other; -- Parent to the 'other' ScreenGui
                    Visible = false;
            Size = UDim2.new(0, 161, 0, 180);
                    Name = "\0_ColorPickerPopup";
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    ZIndex = 100; -- High ZIndex to appear on top
      BorderSizePixel = 1; -- Add border
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0);
                    Position = UDim2.new(0,0,0,0); -- Positioned dynamically
                });
 items[ "_corner1" ] = library:create( "UICorner" , {
                    Parent = items[ "colorpicker_outline" ];
                    Name = "\0";
                    CornerRadius = UDim.new(0, 0)
                });
 items[ "colorpicker_inline" ] = library:create( "Frame" , {
                    Parent = items[ "colorpicker_outline" ];
                    Size = UDim2.new(1, -2, 1, -2);
                    Name = "\0";
                    ClipsDescendants = true;
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Position = UDim2.new(0, 1, 0, 1);
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(32, 32, 32)
           });
 items[ "_corner2" ] = library:create( "UICorner" , {
                    Parent = items[ "colorpicker_inline" ];
                    Name = "\0";
                    CornerRadius = UDim.new(0, 0)
                });
 items[ "colorpicker_background" ] = library:create( "Frame" , {
                    Parent = items[ "colorpicker_inline" ];
                    Size = UDim2.new(1, -2, 1, -2);
                    Name = "\0";
                    ClipsDescendants = true;
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Position = UDim2.new(0, 1, 0, 1);
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(8, 8, 8)
           });
 items[ "_corner3" ] = library:create( "UICorner" , {
                    Parent = items[ "colorpicker_background" ];
                    Name = "\0";
                    CornerRadius = UDim.new(0, 0)
                });
 items[ "_padding1" ] = library:create( "UIPadding" , {
                    PaddingTop = UDim.new(0, 18);
                    Name = "\0";
                    PaddingBottom = UDim.new(0, 3);
                    Parent = items[ "colorpicker_background" ];
                   PaddingRight = UDim.new(0, 3);
                    PaddingLeft = UDim.new(0, 3)
                });
 items[ "saturation_outline" ] = library:create( "TextButton" , {
                    Name = "\0_SatOutline";
                    AutoButtonColor = false;
                    Text = "";
                    Parent = items[ "colorpicker_background" ];
                 BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(1, -12, 1, -12); -- Relative size
                    Position = UDim2.new(0,0,0,0); -- Top-left aligned within padding
                    BorderSizePixel = 1; -- Add border
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                });


                items[ "color_saturation" ] = library:create( "Frame" , {
                    Parent = items[ "saturation_outline" ];
                    Name = "\0_SatFrame";
                    Position = UDim2.new(0, 1, 0, 1);
       BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(1, -2, 1, -2);
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromHSV(h, 1, 1); -- Initial color based on h
                    ClipsDescendants = true; -- Clip picker handle
                });
 items[ "sat" ] = library:create( "Frame" , {
                    Parent = items[ "color_saturation" ];
                    Name = "\0_SatGradient";
                    Size = UDim2.new(1, 0, 1, 0);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    ZIndex = 2;
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                    BackgroundTransparency = 1; -- Make transparent to see gradient below
                });
 library:create( "UIGradient" , { -- White to transparent gradient for saturation
                    Rotation = 0; -- Horizontal
                    Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 1)};
                    Parent = items[ "sat" ];
                    Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
                                              ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))}
                });
--[[ ... ]]--


 items[ "satval_picker" ] = library:create( "Frame" , {
                    Parent = items[ "color_saturation" ];
                    Size = UDim2.new(0, 5, 0, 5); -- Slightly larger picker
                    Name = "\0_SatValPicker";
                    AnchorPoint = Vector2.new(0.5, 0.5); -- Center anchor
                    Position = UDim2.new(s, 0, 1 - v, 0); -- Initial position based on s/v
                    BorderColor3 = Color3.fromRGB(255, 255, 255); -- White border
                    ZIndex = 4;
                    BorderSizePixel = 1; -- Use border instead of nested frames
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0);
                    BackgroundTransparency = 1; -- Make transparent
           });
--[[ ... ]]--
 items[ "val" ] = library:create( "Frame" , { -- Value gradient (black to transparent)
                    Name = "\0_ValGradient";
                    Parent = items[ "color_saturation" ]; -- Overlay on saturation
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(1, 0, 1, 0);
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0); -- Base color black
                    BackgroundTransparency = 1; -- Make transparent to see gradient below
                    ZIndex = 3; -- Above saturation, below picker
                });
 library:create( "UIGradient" , {
                    Rotation = 90; -- Vertical
                    Parent = items[ "val" ];
                    Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 0)} -- Transparent to Black
                });
 items[ "hue_slider" ] = library:create( "TextButton" , {
                    Parent = items[ "colorpicker_background" ];
                    Name = "\0_HueSlider";
                    AutoButtonColor = false;
                    Text = "";
                  Position = UDim2.new(1, -10, 0, 0); -- Position relative to right edge
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(0, 10, 1, -12); -- Fixed width, relative height
                    BorderSizePixel = 1; -- Add border
             BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                });
 items[ "hue_components" ] = library:create( "Frame" , {
                    Parent = items[ "hue_slider" ];
                    Name = "\0_HueComponents";
                    Position = UDim2.new(0, 1, 0, 1);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(1, -2, 1, -2);
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                    ClipsDescendants = true;
                });
 items[ "_hue_gradient" ] = library:create( "UIGradient" , {
                    Rotation = 90; -- Vertical
                    Parent = items[ "hue_components" ];
                    Name = "\0";
                    Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(0.17, Color3.fromRGB(255, 255, 0)), ColorSequenceKeypoint.new(0.33, Color3.fromRGB(0, 255, 0)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)), ColorSequenceKeypoint.new(0.67, Color3.fromRGB(0, 0, 255)), ColorSequenceKeypoint.new(0.83, Color3.fromRGB(255, 0, 255)), ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))}
                });
 items[ "hue_picker" ] = library:create( "Frame" , {
                    Parent = items[ "hue_components" ];
                    Size = UDim2.new(1, 2, 0, 3); -- Full width + border allowance
                    Name = "\0_HuePicker";
                    AnchorPoint = Vector2.new(0.5, 0.5); -- Center anchor
                    Position = UDim2.new(0.5, 0, 1 - h, 0); -- Initial position based on h
                    BorderColor3 = Color3.fromRGB(255, 255, 255); -- White border
                    ZIndex = 4;
                    BorderSizePixel = 1;
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0);
                    BackgroundTransparency = 1;
           });
--[[ ... ]]--
 items[ "alpha_slider" ] = library:create( "TextButton" , {
                    Parent = items[ "colorpicker_background" ];
                    Name = "\0_AlphaSlider";
                    AutoButtonColor = false;
                    Text = "";
                  Position = UDim2.new(0, 0, 1, -10); -- Position relative to bottom edge
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(1, -12, 0, 10); -- Relative width, fixed height
                    BorderSizePixel = 1; -- Add border
             BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                });
 items[ "alpha_components" ] = library:create( "Frame" , {
                    Parent = items[ "alpha_slider" ];
                    Name = "\0_AlphaComponents";
                    Position = UDim2.new(0, 1, 0, 1);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(1, -2, 1, -2);
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255); -- White background for gradient visibility
                    ClipsDescendants = true;
                });
 items[ "_alpha_gradient" ] = library:create( "UIGradient" , {
                    Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.fromHSV(h,s,v))}; -- Black to Current Color
                    Rotation = 0; -- Horizontal
                    Name = "\0";
                    Parent = items[ "alpha_components" ]
                });


                 -- Checkered background for alpha slider
                 items[ "alpha_checkered" ] = library:create( "ImageLabel" , {
                    ScaleType = Enum.ScaleType.Tile;
                    ImageTransparency = 0.5; -- Make checkers semi-transparent
                    TileSize = UDim2.new(0, 4, 0, 4); -- Smaller checkers
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Parent = items[ "alpha_components" ];
                    Name = "\0_AlphaCheckered";
                    Image = "rbxassetid://1693978845"; -- Standard checker pattern asset ID (verify)
                    BackgroundTransparency = 1;
                    Size = UDim2.new(1, 0, 1, 0);
                    BorderSizePixel = 0;
                    ZIndex = 1; -- Below gradient
                });



 items[ "alpha_picker" ] = library:create( "Frame" , {
                    Parent = items[ "alpha_components" ];
                    Size = UDim2.new(0, 3, 1, 2); -- Full height + border allowance
                    Name = "\0_AlphaPicker";
                    AnchorPoint = Vector2.new(0.5, 0.5); -- Center anchor
                    Position = UDim2.new(1 - a, 0, 0.5, 0); -- Initial position based on alpha
                    BorderColor3 = Color3.fromRGB(255, 255, 255); -- White border
                    ZIndex = 4;
                    BorderSizePixel = 1;
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0);
                    BackgroundTransparency = 1;
           });
--[[ ... ]]--
 items[ "visualize_outline" ] = library:create( "Frame" , {
                    AnchorPoint = Vector2.new(1, 1);
                    Parent = items[ "colorpicker_background" ];
                    Name = "\0_VisualizeOutline";
                    Position = UDim2.new(1, -3, 1, -3); -- Position inside padding
 BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(0, 10, 0, 10); -- Fixed size
                    BorderSizePixel = 1; -- Add border
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });
 items[ "visualizer" ] = library:create( "Frame" , {
                    Parent = items[ "visualize_outline" ];
                    Name = "\0_VisualizerColor";
                    Position = UDim2.new(0, 1, 0, 1);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Size = UDim2.new(1, -2, 1, -2);
                    BorderSizePixel = 0;
                    BackgroundColor3 = cfg.color; -- Initial color
                    ClipsDescendants = true; -- Clip alpha visualizer
                });
 items[ "alpha_visualizer" ] = library:create( "ImageLabel" , {
                    ScaleType = Enum.ScaleType.Tile;
                    ImageTransparency = 0.4; -- Adjust transparency
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Parent = items[ "visualizer" ];
                   Name = "\0_VisualizerAlpha";
                    Image = "rbxassetid://1693978845"; -- Standard checker pattern asset ID (verify)
                    BackgroundTransparency = a; -- Set initial transparency (0=opaque, 1=transparent)
                    Size = UDim2.new(1, 0, 1, 0);

                    TileSize = UDim2.new(0, 4, 0, 4); -- Smaller checkers
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(128, 128, 128); -- Grey background for checkers
                    ZIndex = 1; -- Below color
                });
 items[ "close_gear" ] = library:create( "ImageButton" , { -- Renamed for clarity
                    ImageColor3 = Color3.fromRGB(178, 178, 178);
                    AutoButtonColor = false;
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Parent = items["colorpicker_inline" ];
                    Name = "\0_CloseGear";
                    Image = "rbxassetid://9947371938"; -- Verify asset ID
                    BackgroundTransparency = 1;
                    Position = UDim2.new(0, 4, 0, 3);

                    Size = UDim2.new(0, 12, 0, 12);
                    BorderSizePixel = 0;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                    ZIndex = 5; -- Above background elements
                });
 items["picker_title"] = library:create( "TextLabel" , {
                    FontFace = library.font;
                    TextColor3 = Color3.fromRGB(178, 178, 178);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Text = cfg.name;
                Parent = items[ "colorpicker_inline" ]; -- Parent to inline frame
                    Name = cfg.name .. "_PickerTitle";
                    BackgroundTransparency = 1;
                    Position = UDim2.new(0, 20, 0, 3); -- Position next to close gear
                    BorderSizePixel = 0;
        AutomaticSize = Enum.AutomaticSize.XY;
                    TextSize = 10;
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                     ZIndex = 5; -- Above background elements
                });
 library:create( "UIStroke" , {
                    Parent = items[ "picker_title" ]
                });
--[[ ... ]]--
 --
        end;
 function cfg.set_visible(bool)
            if bool then
                 library.other.Enabled = true -- Enable screen gui
                 library:close_current_element(cfg) -- Close other popups

                 local gearPos = items.gear_holder.AbsolutePosition
                 local gearSize = items.gear_holder.AbsoluteSize
                 local pickerSize = items.colorpicker_outline.AbsoluteSize
                 local viewportSize = workspace.CurrentCamera.ViewportSize

                 -- Calculate position relative to gear, clamping to viewport
                 local xPos = math.clamp(gearPos.X + gearSize.X + 5, 0, viewportSize.X - pickerSize.X)
                 local yPos = math.clamp(gearPos.Y, 0, viewportSize.Y - pickerSize.Y)

                 items.colorpicker_outline.Position = UDim2.fromOffset(xPos, yPos)
                 items.colorpicker_outline.Visible = true
                 library.current = cfg -- Set this as the current open element
            else
                 items.colorpicker_outline.Visible = false
                 if library.current == cfg then library.current = nil end -- Clear current if this was it

                 -- Check if any other popups are open before disabling screen gui
                 local anyPopupOpen = false
                 for _, child in ipairs(library.other:GetChildren()) do
                     if child:IsA("Frame") and child.Visible and child.Name:find("Popup") then
                         anyPopupOpen = true
                         break
                     end
                 end
                 if not anyPopupOpen then library.other.Enabled = false end
            end
        end


        function cfg.set(color, alpha_val) -- Use distinct name for alpha parameter
             local update_callback = true


            if color == nil and alpha_val == nil then -- Called from update_color, don't call callback
                update_callback = false
             end


            if color then
   h, s, v = color:ToHSV()
            end


            if alpha_val ~= nil then -- Check if alpha value is provided (0=opaque, 1=transparent)
                a = alpha_val
            end



            local CurrentColor = Color3.fromHSV(h, s, v)


            -- Update Picker Positions
            items.hue_picker.Position = UDim2.new(0.5, 0, 1 - h, 0)
            items.alpha_picker.Position = UDim2.new(1 - a, 0, 0.5, 0) -- Alpha pos (0=left, 1=right) -> (1-a)
            items.satval_picker.Position = UDim2.new(s, 0, 1 - v, 0)


            -- Update Background Colors/Gradients
            items.color_saturation.BackgroundColor3 = Color3.fromHSV(h, 1, 1)
            items["_alpha_gradient"].Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(1, CurrentColor)}


            -- Update Visualizer
--[[ ... ]]--


            items.alpha_visualizer.BackgroundTransparency = a -- Alpha visualizer uses alpha directly
            items.visualizer.BackgroundColor3 = CurrentColor


             -- Update flag and call callback only if color or alpha was actually changed
             if flags[cfg.flag].Color ~= CurrentColor or flags[cfg.flag].Transparency ~= a then
                 flags[cfg.flag] = {
                     Color = CurrentColor;
 Transparency = a -- Store alpha value (0 = opaque, 1 = transparent)
                 }
                  if update_callback then
                     pcall(cfg.callback, CurrentColor, a) -- Wrap callback
                  end
             end
        end



        function cfg.update_color()
            local mouseLocation = game:GetService("UserInputService"):GetMouseLocation()
            local guiInset = game:GetService("GuiService"):GetGuiInset().Y
            local offset = Vector2.new(mouseLocation.X, mouseLocation.Y) -- Don't subtract inset here


            local new_h, new_s, new_v, new_a = h, s, v, a -- Store current values


            if dragging_sat then
                 local satFrame = items.color_saturation
                 local relativePos = offset - satFrame.AbsolutePosition
                 new_s = math.clamp(relativePos.X / satFrame.AbsoluteSize.X, 0, 1)
                 new_v = 1 - math.clamp(relativePos.Y / satFrame.AbsoluteSize.Y, 0, 1)
            elseif dragging_hue then
                 local hueFrame = items.hue_slider
                 local relativePos = offset - hueFrame.AbsolutePosition
                 new_h = 1 - math.clamp(relativePos.Y / hueFrame.AbsoluteSize.Y, 0, 1)
            elseif dragging_alpha then
                 local alphaFrame = items.alpha_slider
                 local relativePos = offset - alphaFrame.AbsolutePosition
                 new_a = 1 - math.clamp(relativePos.X / alphaFrame.AbsoluteSize.X, 0, 1) -- 0=opaque, 1=transparent
            end


             -- Only call set if values actually changed
            if new_h ~= h or new_s ~= s or new_v ~= v or new_a ~= a then
                 h, s, v, a = new_h, new_s, new_v, new_a -- Update internal state
                 cfg.set(nil, nil) -- Call set to update visuals without triggering callback
            end
        end


        -- Open picker
        items.gear_holder.MouseButton1Click:Connect(function()
             if not cfg.open then
                 cfg.open = true
                 cfg.set_visible(true)
             end
        end)


        -- Close picker
   items.close_gear.MouseButton1Click:Connect(function() -- Use close_gear now
             if cfg.open then
                 cfg.open = false
                 cfg.set_visible(false)
             end
        end)


        -- Handle dragging updates
         library:connection(game:GetService("UserInputService").InputChanged, function(input)
            if (dragging_sat or dragging_hue or dragging_alpha) and input.UserInputType == Enum.UserInputType.MouseMovement then
                 cfg.update_color()
            end
        end)


        -- Stop dragging and handle clicks outside picker
        library:connection(game:GetService("UserInputService").InputEnded, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                 local was_dragging = dragging_sat or dragging_hue or dragging_alpha
                 dragging_sat = false
                 dragging_hue = false
                 dragging_alpha = false


                 task.wait() -- Wait a frame before checking mouse position


                 if cfg.open and not was_dragging and not (library:mouse_in_frame(items.gear_holder) or library:mouse_in_frame(items.colorpicker_outline)) then
                    cfg.open = false
                    cfg.set_visible(false)
                 elseif cfg.open and was_dragging then
                     -- Update flag and callback *after* dragging stops
                     local finalColor = Color3.fromHSV(h, s, v)
                     flags[cfg.flag] = { Color = finalColor, Transparency = a }
                     pcall(cfg.callback, finalColor, a) -- Wrap callback
                end
            end
        end)


        -- Start dragging listeners
        items.alpha_slider.MouseButton1Down:Connect(function()
   dragging_alpha = true; cfg.update_color() -- Initial update on click
        end)


        items.hue_slider.MouseButton1Down:Connect(function()
            dragging_hue = true; cfg.update_color() -- Initial update on click
        end)


        items.saturation_outline.MouseButton1Down:Connect(function()
            dragging_sat = true; cfg.update_color() -- Initial update on click
     end)


        flags[cfg.flag] = { Color = cfg.color, Transparency = cfg.alpha } -- Initialize flag
        cfg.set(cfg.color, cfg.alpha) -- Initial set (visuals only)


        config_flags[cfg.flag] = function(color_or_table, alpha_val) -- Modify config setter
             if type(color_or_table) == "table" and color_or_table.Color and color_or_table.Transparency ~= nil then
                 cfg.set(Color3.fromHex(color_or_table.Color), color_or_table.Transparency) -- Convert from hex
             elseif typeof(color_or_table) == "Color3" and alpha_val ~= nil then
                 cfg.set(color_or_table, alpha_val)
             end
         end


        -- Label created earlier as part of the object frame


        return setmetatable(cfg, library)
    end


    function library:Textbox(options)
        local cfg = {
            name = options.name or options.Name or "TextBox",
            placeholder = options.placeholder or options.PlaceHolder or "type here...",
    default = options.default or options.Default or "",
            flag = options.flag or options.name or "please set me a flag ðŸ¥º",
            callback = options.callback or options.Callback or function() end,
            visible = options.visible or true, -- This seems unused in original code
            items = {};
 }


        flags[cfg.flag] = cfg.default


        local items = cfg.items;
 do
            items[ "object" ] = library:create( "Frame" , {
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Parent = self.items[ "elements" ];
                BackgroundTransparency = 1;
                Name = cfg.name .. "_TextboxObject";
            Size = UDim2.new(1, 0, 0, 20); -- Full width, fixed height
                BorderSizePixel = 0;
                -- AutomaticSize = Enum.AutomaticSize.Y; -- Use fixed height
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });
 items[ "textbox_outline" ] = library:create( "Frame" , {
                Name = "\0_TextboxOutline";
                Parent = items[ "object" ];
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, 0, 1, 0); -- Fill the object frame
              BorderSizePixel = 1; -- Add border
                BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });
 items[ "textbox_shading" ] = library:create( "Frame" , {
                Parent = items[ "textbox_outline" ];
                Name = "\0_TextboxShading";
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
              Size = UDim2.new(1, -2, 1, -2);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                ClipsDescendants = true; -- Clip text
            });
 items[ "textbox" ] = library:create( "TextBox" , {
                FontFace = library.font;
                Active = true; -- Allow interaction
                Selectable = true; -- Allow selection
                PlaceholderText = cfg.placeholder;
                PlaceholderColor3 = Color3.fromRGB(90, 90, 90); -- Darker placeholder
                TextSize = 10;
             Size = UDim2.new(1, 0, 1, 0); -- Fill shading frame
                TextColor3 = Color3.fromRGB(180, 180, 180);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Text = cfg.default; -- Start with default text
                Parent = items[ "textbox_shading" ];
            Name = "\0_TextboxInput";
                ClearTextOnFocus = false; -- Don't clear text on focus
                BackgroundTransparency = 1;
                TextXAlignment = Enum.TextXAlignment.Left;
                TextYAlignment = Enum.TextYAlignment.Center; -- Center text vertically
                BorderSizePixel = 0;
              -- TextWrapped = true; -- Disable wrapping for single line
                -- AutomaticSize = Enum.AutomaticSize.XY; -- Use fixed size
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });
 library:create( "UIPadding" , {
                PaddingLeft = UDim.new(0, 7);
                PaddingRight = UDim.new(0, 7); -- Add right padding
                Parent = items[ "textbox" ]
            });
 library:create( "UIStroke" , {
                Parent = items[ "textbox" ]
            });
 library:create( "UIGradient" , {
                Rotation = 90;
                Parent = items[ "textbox_shading" ];
                Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(33, 33, 33)), ColorSequenceKeypoint.new(1, Color3.fromRGB(8, 8, 8))}
            });
 --[[ ... layout removal ... ]]--


            -- Create label if name is provided
             if cfg.name then
                 -- Use a frame to hold the label for layout purposes
                 local labelFrame = library:create("Frame", {
                     Parent = items["object"];
                     BackgroundTransparency = 1;
                     Size = UDim2.new(0.4, 0, 1, 0); -- Adjust width as needed
                     Name = cfg.name .. "_TextboxLabelFrame";
                     LayoutOrder = 1; -- Place before textbox outline
                 })
                 local labelText = library:create("TextLabel", {
                     Parent = labelFrame;
                     FontFace = library.font;
                     TextColor3 = Color3.fromRGB(178, 178, 178);
                     Text = cfg.name;
                     Name = cfg.name .. "_TextboxLabel";
                     TextSize = 10;
                     BackgroundTransparency = 1;
                     Size = UDim2.new(1, 0, 1, 0);
                     TextXAlignment = Enum.TextXAlignment.Left;
                     TextYAlignment = Enum.TextYAlignment.Center;
                 })
                  library:create( "UIStroke" , { Parent = labelText });


                 -- Adjust textbox outline size
                 items["textbox_outline"].Size = UDim2.new(0.6, 0, 1, 0); -- Adjust width
                 items["textbox_outline"].LayoutOrder = 2;


                 -- Add list layout to the main object frame
                 library:create("UIListLayout", {
                     Parent = items["object"];
                     FillDirection = Enum.FillDirection.Horizontal;
                     VerticalAlignment = Enum.VerticalAlignment.Center;
                     Padding = UDim.new(0, 5);
                     SortOrder = Enum.SortOrder.LayoutOrder;
                 })


             end


 end


        function cfg.set(text)
            if type(text) == "boolean" then -- Disallow boolean input
                return
            end
             local text_str = tostring(text) -- Ensure it's a string

            if flags[cfg.flag] ~= text_str then -- Only update if value changed
                flags[cfg.flag] = text_str
                items[ "textbox" ].Text = text_str -- Update textbox content
                 pcall(cfg.callback, text_str) -- Wrap callback
            end
        end



        -- Use GetPropertyChangedSignal("Text") for real-time updates
        items[ "textbox" ]:GetPropertyChangedSignal("Text"):Connect(function()
             -- Check if the current text is different from the flag to avoid loops
             if items[ "textbox" ].Text ~= flags[cfg.flag] then
                cfg.set(items[ "textbox" ].Text)
             end
        end)


        items[ "textbox" ].Focused:Connect(function()
            library:tween(items[ "textbox" ], {TextColor3 = Color3.fromRGB(245, 245, 245)})
        end)


   items[ "textbox" ].FocusLost:Connect(function(enterPressed) -- EnterPressed indicates if Enter was hit
             library:tween(items[ "textbox" ], {TextColor3 = Color3.fromRGB(180, 180, 180)}) -- Revert color
             -- Callback is triggered by TextChanged signal, no need here unless specific logic needed on focus lost without enter
        end)



        flags[cfg.flag] = cfg.default -- Initialize flag
        cfg.set(cfg.default) -- Set initial text


        config_flags[cfg.flag] = cfg.set


        return setmetatable(cfg, library)
 end


    function library:Keybind(options)
        local cfg = {
            -- options
            flag = options.flag or options.Flag or options.name or options.Name or "please set me a flag ðŸ¥º",
            callback = options.callback or options.Callback or function() end,
            name = options.name or options.Name or nil,
       key = options.key or options.Key or "None", -- Default to "None"
            mode = options.mode or options.Mode or "Toggle",
            active = options.default or options.Default or false,


            -- ignore
            open = false,
            binding = false, -- Changed to boolean flag
     hold_instances = {},
            items = {};
 }


         -- Convert string key to Enum if possible on init
         if type(cfg.key) == "string" and cfg.key ~= "None" then
             local success, result = pcall(function() return library:convert_enum("Enum.KeyCode." .. cfg.key) end)
             if success and result then cfg.key = result else
                 success, result = pcall(function() return library:convert_enum("Enum.UserInputType." .. cfg.key) end)
                 if success and result then cfg.key = result else cfg.key = "None" end -- Default to None if invalid string
             end
         elseif typeof(cfg.key) ~= "EnumItem" then
              cfg.key = "None" -- Ensure it's Enum or None
         end


        flags[cfg.flag] = {
            mode = cfg.mode,
            key = cfg.key,
            active = cfg.active
        }


        local items = cfg.items;
 do
            -- Main container for label + button
             items[ "object" ] = library:create("Frame", {
                 Parent = self.items.elements;
                 BackgroundTransparency = 1;
                 Size = UDim2.new(1, 0, 0, 12); -- Full width, fixed height
                 Name = cfg.name .. "_KeybindObject";
             })
             library:create("UIListLayout", {
                 Parent = items["object"];
                 FillDirection = Enum.FillDirection.Horizontal;
                 VerticalAlignment = Enum.VerticalAlignment.Center;
                 HorizontalAlignment = Enum.HorizontalAlignment.Right; -- Align button right
                 Padding = UDim.new(0, 5);
                 SortOrder = Enum.SortOrder.LayoutOrder;
             })


             -- Label (if name provided)
             if cfg.name then
                 local label = self:Label({Name = cfg.name, parent = items.object}) -- Create label inside object
                 label.items.text.LayoutOrder = 1 -- Ensure label comes first
                 label.items.text.Size = UDim2.new(1, -30, 1, 0) -- Adjust size to leave space for button
                 label.items.text.TextXAlignment = Enum.TextXAlignment.Left
             end



            -- Keybind Button
                items.keybind_button = library:create( "TextButton" , { -- Renamed for clarity
                    FontFace = library.font;
                    AutoButtonColor = false;
                    TextColor3 = Color3.fromRGB(178, 178, 178);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Text = "[None]"; -- Placeholder, set later
                    Parent = items.object; -- Parent to the main object frame
                     Name = cfg.name .. "_KeybindButton";
                    BorderSizePixel = 1; -- Add border
             -- AutomaticSize = Enum.AutomaticSize.XY; -- Use fixed/calculated size
                     Size = UDim2.new(0, 0, 1, 0); -- Auto width, fill height
                     AutomaticSize = Enum.AutomaticSize.X;
                    TextSize = 10;
                    BackgroundColor3 = Color3.fromRGB(38, 38, 38);
                    LayoutOrder = 2; -- Ensure button comes after label
                });
 library:create( "UIStroke" , {
                    Parent = items.keybind_button
                });
 -- Omg what the skibidi? "Desktop2677"


                library:create( "UIPadding" , {
                    Parent = items.keybind_button;
                    PaddingRight = UDim.new(0, 4);
                    PaddingLeft = UDim.new(0, 4)
                });


                --[[if cfg.name then ... end ]]--
            --


            -- Mode Holder (Popup)
     items[ "modes" ] = library:create( "Frame" , {
                    Parent = library.other; -- Parent to other screen gui
                    Visible = false;
                    Size = UDim2.new(0, 114, 0, 0); -- Width from original, auto height
  Name = "\0_KeybindModesPopup";
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    BorderSizePixel = 1; -- Add border
                    AutomaticSize = Enum.AutomaticSize.Y;
                    BackgroundColor3 = Color3.fromRGB(0, 0, 0);
                    ZIndex = 10; -- Above main UI
           });
 items[ "mode_shading" ] = library:create( "Frame" , {
                    Parent = items[ "modes" ];
                    Size = UDim2.new(1, -2, 1, -2); -- Fill inside border
                    Name = "\0_ModeShading";
                    Position = UDim2.new(0, 1, 0, 1);
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    BorderSizePixel = 0;
                    AutomaticSize = Enum.AutomaticSize.Y; -- Auto Height
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                    ClipsDescendants = true;
           });
 library:create( "UIGradient" , {
                    Rotation = 90;
                    Parent = items[ "mode_shading" ];
                    Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(33, 33, 33)), ColorSequenceKeypoint.new(1, Color3.fromRGB(8, 8, 8))}
                });
 library:create( "UIListLayout" , {
                    Parent = items[ "mode_shading" ];
                    Padding = UDim.new(0, 5);
                    SortOrder = Enum.SortOrder.LayoutOrder
                });
 library:create( "UIPadding" , {
                    PaddingBottom = UDim.new(0, 5);
                    PaddingTop = UDim.new(0, 5);
                     PaddingLeft = UDim.new(0, 5);
                     PaddingRight = UDim.new(0, 5);
                    Parent = items[ "mode_shading" ]
                });
--[[ ... ]]--
 local options = {"Hold", "Toggle", "Always", "None"} -- Added None mode


                for _,option in ipairs(options) do -- Use ipairs
                    local name = library:create( "TextButton" , {
                        FontFace = library.font;
                 AutoButtonColor = false;
                        TextColor3 = Color3.fromRGB(178, 178, 178);
                        BorderColor3 = Color3.fromRGB(0, 0, 0);
                        Text = option;
                        Parent = items[ "mode_shading" ];
                         Name = option .. "_ModeOption";
                        BackgroundTransparency = 1;
                        Size = UDim2.new(1, 0, 0, 0); -- Full width, auto height
        BorderSizePixel = 0;
                        AutomaticSize = Enum.AutomaticSize.XY;
                        TextSize = 10;
                        TextXAlignment = Enum.TextXAlignment.Left; -- Align text left
                        BackgroundColor3 = Color3.fromRGB(255, 255, 255)
          });
 cfg.hold_instances[option] = name


                    library:create( "UIStroke" , {
                        Parent = name -- Apply stroke to option text
                    });
 --[[ library:create( "UIPadding" , { ... }); -- Padding handled by parent ]]--
 -- cfg.y_size += name.AbsoluteSize.Y -- Not needed with AutomaticSize


                    --[[ library:create( "UIPadding" , { ... }); -- Handled above ]]--
 name.MouseButton1Click:Connect(function()
                         if cfg.binding then return end -- Don't change mode while binding key
                        cfg.set_mode(option) -- Use set_mode function
                        cfg.set_visible(false)
                        cfg.open = false
                    end)
          end
            --
        end


        function cfg.modify_mode_color(selected_mode) -- ts so frikin tuff ðŸ’€
            for mode, instance in pairs(cfg.hold_instances) do
                 instance.TextColor3 = (mode == selected_mode) and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(178, 178, 178)
        end
        end


         -- Function to update button text based on key
        function cfg.update_button_text()
             local text = "None"
             if cfg.key and cfg.key ~= "None" then
                 text = keys[cfg.key] or tostring(cfg.key):gsub("Enum.KeyCode.", ""):gsub("Enum.UserInputType.", "")
             end
             items.keybind_button.Text = "[" .. text .. "]"
         end



        function cfg.set_mode(mode)
            if cfg.mode == mode then return end -- No change


            cfg.mode = mode
            flags[cfg.flag].mode = mode
            cfg.modify_mode_color(mode) -- Update colors in popup


             -- Update active state based on new mode
            if mode == "Always" then
                 cfg.set_active(true, true) -- Set active, force update
            elseif mode == "None" then
                 cfg.set_active(false, true) -- Set inactive, force update
             elseif mode == "Hold" and cfg.active then -- If switching to Hold while active, deactivate
                  cfg.set_active(false, true)
             end
             -- For Toggle, active state remains unchanged unless forced by Always/None
        end


        function cfg.set_key(key)
             local newKeyEnum = key

             -- Handle "None" string or actual nil/false value
             if not key or key == "None" or key == Enum.KeyCode.Escape then
                 newKeyEnum = "None"
             elseif type(key) == "string" then
                 -- Attempt to convert string to Enum
                 local success, result = pcall(library.convert_enum, library, "Enum.KeyCode." .. key)
                 if success and result then
                     newKeyEnum = result
                 else
                     success, result = pcall(library.convert_enum, library, "Enum.UserInputType." .. key)
                     if success and result then
                         newKeyEnum = result
                     else
                         newKeyEnum = "None" -- Default to None if string is not a valid key/type
                     end
                 end
             elseif typeof(key) ~= "EnumItem" then
                 newKeyEnum = "None" -- Ensure it's a valid EnumItem or "None"
             end


             if newKeyEnum == cfg.key then return end -- No change

             cfg.key = newKeyEnum
             flags[cfg.flag].key = cfg.key
             cfg.update_button_text()

             -- Deactivate if setting key to None while active
             if cfg.key == "None" and cfg.active then
                 cfg.set_active(false, true)
             end
         end


        function cfg.set_active(newState, forceUpdate)
             if type(newState) ~= "boolean" then return end -- Type check
            -- Only update if state changes or forced
            if newState ~= cfg.active or forceUpdate then
                 cfg.active = newState
                 flags[cfg.flag].active = cfg.active
                 pcall(cfg.callback, cfg.active) -- Trigger callback on state change, wrap in pcall
             end
        end


        -- Combined set function for config loading
        function cfg.set_from_config(config_table)
             if type(config_table) ~= "table" then return end -- Ensure input is a table

             local key_to_set = config_table.key or "None"
             local mode_to_set = config_table.mode or "Toggle"
             local active_to_set = config_table.active -- Could be boolean or nil

             cfg.set_key(key_to_set) -- Set key first
             cfg.set_mode(mode_to_set) -- Set mode after key, handles 'Always'/'None' activation


              -- Set active state *after* mode, respecting Always/None modes
              if active_to_set ~= nil and cfg.mode ~= "Always" and cfg.mode ~= "None" then
                 cfg.set_active(active_to_set, true) -- Force update if value provided and not Always/None
              elseif cfg.mode == "Always" then
                  cfg.set_active(true, true)
              elseif cfg.mode == "None" then
                   cfg.set_active(false, true)
              end
         end


        --[[ ... Old set function logic commented out ... ]]--


        function cfg.set_visible(bool)
            if bool then
                 library.other.Enabled = true -- Enable screen gui
                 library:close_current_element(cfg) -- Close other popups
                 local btnPos = items.keybind_button.AbsolutePosition
                 local btnSize = items.keybind_button.AbsoluteSize
                 items.modes.Position = UDim2.fromOffset(btnPos.X, btnPos.Y + btnSize.Y + 2) -- Position below button
                 items.modes.Visible = true
                 library.current = cfg -- Set this as current popup
            else
                 items.modes.Visible = false
                 if library.current == cfg then library.current = nil end -- Clear current if this was it
                 -- Check if any other popups are open before disabling screen gui
                 local anyPopupOpen = false
                 for _, child in ipairs(library.other:GetChildren()) do
                     if child:IsA("Frame") and child.Visible and child.Name:find("Popup") then
                         anyPopupOpen = true
                         break
                     end
                 end
                 if not anyPopupOpen then library.other.Enabled = false end
            end
        end


        -- Start binding process
        items.keybind_button.MouseButton1Click:Connect(function()
             if cfg.binding or cfg.open then return end -- Prevent starting if already binding or popup open
             cfg.binding = true
             items.keybind_button.Text = "[...]"
             items.keybind_button.TextColor3 = Color3.fromRGB(255, 255, 255) -- Indicate binding state


              -- Disconnect previous listener if exists (shouldn't happen with flag, but safety)
             if items.binding_connection then items.binding_connection:Disconnect(); items.binding_connection = nil end


             -- Listen for the next input
             items.binding_connection = game:GetService("UserInputService").InputBegan:Connect(function(input, game_event)
                 if not game_event and cfg.binding then -- Only process if binding and not processed by game
                     local newKey = input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode or input.UserInputType

                      cfg.binding = false -- Stop binding immediately
                      if items.binding_connection then items.binding_connection:Disconnect(); items.binding_connection = nil end -- Disconnect listener
                      items.keybind_button.TextColor3 = Color3.fromRGB(178, 178, 178) -- Revert color

                      cfg.set_key(newKey) -- Set the new key (handles Escape mapping to "None")
                end
             end)
        end)



        -- Open/Close mode selection popup
        items.keybind_button.MouseButton2Click:Connect(function()
             if cfg.binding then return end -- Don't open popup if binding
            cfg.open = not cfg.open
            cfg.set_visible(cfg.open)
        end)


        -- Input handling for keybind activation
        library:connection(game:GetService("UserInputService").InputBegan, function(input, game_event)
            if not game_event and not cfg.binding and cfg.key ~= "None" then
                local selected_key = input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode or input.UserInputType


                if selected_key == cfg.key then
               if cfg.mode == "Toggle" then
                        cfg.set_active(not cfg.active, false) -- Toggle state, don't force
                    elseif cfg.mode == "Hold" then
                    cfg.set_active(true, false) -- Activate on hold, don't force
                    end
                end
            end
        end)


        library:connection(game:GetService("UserInputService").InputEnded, function(input, game_event)
   if not game_event and not cfg.binding and cfg.key ~= "None" then -- Check not game_event and not binding
                local selected_key = input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode or input.UserInputType


                if selected_key == cfg.key then
                    if cfg.mode == "Hold" then
              cfg.set_active(false, false) -- Deactivate on hold release, don't force
                    end
                end
            end
 end)


        -- Handle clicks outside popup
        library:connection(game:GetService("UserInputService").InputEnded, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                 task.wait() -- Wait a frame
                 if cfg.open and not cfg.binding and not (library:mouse_in_frame(items[ "modes" ]) or library:mouse_in_frame(items.keybind_button)) then
                    cfg.open = false
                    cfg.set_visible(false)
       end
            end
        end)


         -- Initial setup
         cfg.update_button_text() -- Set initial button text
         cfg.modify_mode_color(cfg.mode) -- Set initial mode color in popup
         if cfg.mode == "Always" then cfg.set_active(true, true) end -- Ensure 'Always' is active initially
         if cfg.mode == "None" then cfg.set_active(false, true) end -- Ensure 'None' is inactive initially


         config_flags[cfg.flag] = cfg.set_from_config -- Use combined setter for config loading


        return setmetatable(cfg, library)
    end


    function library:Button(options)
 local cfg = {
            -- options
            name = options.name or options.Name or "Button", -- Default name to "Button"
            callback = options.callback or options.Callback or function() end,


            -- ignore
            items = {};
 }


        local items = cfg.items;
 do
            items[ "button" ] = library:create( "TextButton" , {
                Parent = self.items[ "elements" ];
                Name = cfg.name .. "_ButtonObject";
                AutoButtonColor = false;
                BackgroundTransparency = 1; -- Make main button transparent
          Size = UDim2.new(1, 0, 0, 20); -- Full width, fixed height
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                BorderSizePixel = 0;
               -- AutomaticSize = Enum.AutomaticSize.Y; -- Use fixed height
                BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                Text = ""; -- No text on wrapper
       });


            items[ "button_outline" ] = library:create( "Frame" , {
                Name = "\0_ButtonOutline";
                Parent = items[ "button" ];
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, 0, 1, 0); -- Fill parent
      BorderSizePixel = 1; -- Add border
                BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            });
 items[ "button_shading" ] = library:create( "Frame" , {
                Parent = items[ "button_outline" ];
                Name = "\0_ButtonShading";
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
              Size = UDim2.new(1, -2, 1, -2);
                BorderSizePixel = 0;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                ClipsDescendants = true; -- Clip text
            });
 library:create( "UIGradient" , {
                Rotation = 90;
                Parent = items[ "button_shading" ];
                Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(33, 33, 33)), ColorSequenceKeypoint.new(1, Color3.fromRGB(8, 8, 8))}
            });
 items[ "button_text" ] = library:create( "TextLabel" , {
                FontFace = library.font;
                TextColor3 = Color3.fromRGB(178, 178, 178);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Text = cfg.name;
                Parent = items[ "button_shading" ];
                Name = "\0_ButtonText";
                BackgroundTransparency = 1;
                Size = UDim2.new(1, 0, 1, 0); -- Fill shading
                BorderSizePixel = 0;
                TextXAlignment = Enum.TextXAlignment.Center; -- Center text
                TextYAlignment = Enum.TextYAlignment.Center;
               -- AutomaticSize = Enum.AutomaticSize.XY;
            TextSize = 10;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });
 library:create( "UIStroke" , {
                Parent = items[ "button_text" ]
            });
--[[ ... layout removal ... ]]--
 end


        items[ "button" ].MouseButton1Click:Connect(function()
            pcall(cfg.callback) -- Wrap callback


             -- Quick flash effect
            items[ "button_text" ].TextColor3 = Color3.fromRGB(255, 255, 255)
            library:tween(items[ "button_text" ], {TextColor3 = Color3.fromRGB(178, 178, 178)}, Enum.EasingStyle.Quad, 0.2) -- Slightly longer tween
        end)


        return setmetatable(cfg, library)
    end


    function library:list(properties)
     local cfg = {
            items = {};
 options = properties.options or {""}; -- Default to empty option
            flag = properties.flag or options.name or "please set me a flag ðŸ¥º"; -- Use name if flag missing
            default = properties.default or nil; -- Add default option
 callback = properties.callback or function() end;
            data_store = {};
            current_element = nil; -- Store the TextLabel of the selected element
 }


        flags[cfg.flag] = cfg.default -- Initialize flag


        local items = cfg.items;
 do
            items[ "list" ] = library:create( "Frame" , {
                Parent = self.items[ "elements" ];
                BackgroundTransparency = 1;
                Name = "\0_ListContainer";
                Size = UDim2.new(1, 0, 0, 0); -- Full width, auto height
            BorderColor3 = Color3.fromRGB(0, 0, 0);
                BorderSizePixel = 0;
                AutomaticSize = Enum.AutomaticSize.Y; -- Auto height based on content
                BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            });
 library:create( "UIListLayout" , {
                Parent = items[ "list" ];
                Padding = UDim.new(0, 2); -- Reduce padding between list items
                SortOrder = Enum.SortOrder.LayoutOrder
            });
--[[ ... padding removal ... ]]--
 end


        function cfg.set_selected(button_element, text_label, option_data)
             local current_value = flags[cfg.flag]
             -- Deselect previous
            if cfg.current_element and cfg.current_element ~= text_label then
                 if cfg.current_element.Parent then -- Check if valid
                     library:tween(cfg.current_element, {TextColor3 = Color3.fromRGB(72, 72, 72)})
                     cfg.current_element.Parent.BackgroundColor3 = Color3.fromRGB(33, 33, 35) -- Reset background
                 end
            end


             -- Select new
             flags[cfg.flag] = option_data
             library:tween(text_label, {TextColor3 = Color3.fromRGB(245, 245, 245)})
             button_element.BackgroundColor3 = Color3.fromRGB(50, 50, 55) -- Highlight background
             cfg.current_element = text_label

             if current_value ~= option_data then -- Only call callback if value changed
                 pcall(cfg.callback, option_data) -- Wrap callback
             end
         end



        function cfg.refresh_options(options_to_refresh) -- ignore goofy parameter
             local current_value = flags[cfg.flag] -- Store current value
            -- Clear existing options
            for _,button in ipairs(cfg.data_store) do -- Use ipairs
                 pcall(function() button:Destroy() end) -- Wrap destroy
            end
            cfg.data_store = {}
            cfg.current_element = nil


            for _, option_data in ipairs(options_to_refresh) do -- Use ipairs
 button = library:create( "TextButton" , {
                    FontFace = library.font; -- Use library font
                    TextColor3 = Color3.fromRGB(0, 0, 0); -- Text color set by label
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                    Text = "";
                 AutoButtonColor = false;
                    -- AnchorPoint = Vector2.new(1, 0); -- Not needed with list layout
                    Parent = items[ "list" ];
                    Name = "\0_" .. tostring(option_data); -- Give more specific name
        -- Position = UDim2.new(1, 0, 0, 0); -- Position handled by layout
                    Size = UDim2.new(1, 0, 0, 20); -- Full width, fixed height
                    BorderSizePixel = 0;
                    TextSize = 10; -- Consistent text size
                  BackgroundColor3 = Color3.fromRGB(33, 33, 35) -- Original background color
                });
 table.insert(cfg.data_store, button); -- Store button instance


                local name_label = library:create( "TextLabel" , { -- Renamed variable
                    FontFace = library.font;
                    TextColor3 = Color3.fromRGB(72, 72, 73); -- Initial text color
                    BorderColor3 = Color3.fromRGB(0, 0, 0);
                 Text = option_data;
                    Parent = button;
                    Name = "\0_Label";
                    BackgroundTransparency = 1;
                    Size = UDim2.new(1, -10, 1, 0); -- Fill button width minus padding
                    Position = UDim2.new(0, 5, 0, 0); -- Position with padding
              BorderSizePixel = 0;
                    TextXAlignment = Enum.TextXAlignment.Left; -- Align left
                    TextYAlignment = Enum.TextYAlignment.Center; -- Center vertically
                    -- AutomaticSize = Enum.AutomaticSize.XY; -- Size controlled by fixed parent size
                    TextSize = 10; -- Consistent text size
                    BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                     ZIndex = 2; -- Above button background
                });
                 library:create("UIStroke", { Parent = name_label });


 button.MouseButton1Click:Connect(function()
                    cfg.set_selected(button, name_label, option_data)
 end)


                button.MouseEnter:Connect(function()
                    if cfg.current_element == name_label then
                        return
                    end
                    library:tween(name_label, {TextColor3 = Color3.fromRGB(140, 140, 140)})
                end)


                button.MouseLeave:Connect(function()
                    if cfg.current_element == name_label then
                        return
                    end
                    library:tween(name_label, {TextColor3 = Color3.fromRGB(72, 72, 72)})
                end)


                 -- Set initial selection if this option is the current/default
                 if option_data == current_value or (current_value == nil and option_data == cfg.default) then
                     cfg.set_selected(button, name_label, option_data)
                 end
            end
        end


        cfg.refresh_options(cfg.options)
         -- Initialize flag if not set by default match
         if flags[cfg.flag] == nil then flags[cfg.flag] = cfg.default end


        return setmetatable(cfg, library)
   end


    function library:ConfigTab(window)
        local textbox;
 local main = window:Page({name = "Configs", icon = "rbxassetid://72506063321241"}) -- Icon less relevant now
        local section = main:Section({name = "Settings", side = "left", size = 1, default = true}) -- Changed side to left for single column layout
        config_holder = section:Dropdown({Name = "Configs", options = {""}, callback = function(option) if textbox then textbox.set(option) end end, flag = "config_name_list"}); -- Start with empty option
 library:update_config_list() -- Load actual configs
        textbox = section:Textbox({name = "Config name:", flag = "config_name_text"})
        section:Button({name = "Save", callback = function()
             local configName = flags["config_name_text"]
             if configName and configName ~= "" then
                 local success, err = pcall(writefile, "syphon" .. "/configs/" .. configName .. ".cfg", library:get_config())
                 if not success then
                     library:Notify({name = "Error saving config: " .. err, color = Color3.fromRGB(255,0,0)})
                 else
                      library:Notify({name = "Saved config: " .. configName, color = Color3.fromRGB(0,255,0)})
                 end
                 library:update_config_list()
             else
                 library:Notify({name = "Please enter a config name.", color = Color3.fromRGB(255,0,0)})
             end
          end})
        section:Button({name = "Load", callback = function()
             local configName = flags["config_name_text"]
             local filePath = "syphon" .. "/configs/" .. configName .. ".cfg"
             if isfile(filePath) then
                 local success, content = pcall(readfile, filePath)
                 if success then
                     local load_success, load_err = pcall(library.load_config, library, content)
                     if not load_success then
                         library:Notify({name = "Failed to load config: " .. tostring(load_err), color = Color3.fromRGB(255,0,0)})
                     else
                         library:Notify({name = "Loaded config: " .. configName, color = Color3.fromRGB(0,255,0)})
                     end
                 else
                      library:Notify({name = "Error reading config file: " .. content, color = Color3.fromRGB(255,0,0)})
                 end
             else
                 library:Notify({name = "Config not found: " .. configName, color = Color3.fromRGB(255,0,0)})
             end
             library:update_config_list()
         end})
        section:Button({name = "Delete", callback = function()
             local configName = flags["config_name_text"]
             local filePath = "syphon" .. "/configs/" .. configName .. ".cfg"
              if isfile(filePath) then
                  local success, err = pcall(delfile, filePath)
                  if success then
                     library:Notify({name = "Deleted config: " .. configName})
                     if textbox.items.textbox.Text == configName then textbox.set("") end -- Clear textbox if deleted config was displayed
                  else
                      library:Notify({name = "Error deleting config: " .. err, color = Color3.fromRGB(255,0,0)})
                  end
             else
                  library:Notify({name = "Config not found: " .. configName, color = Color3.fromRGB(255,0,0)})
             end
             library:update_config_list()
         end})


        local uiBindSection = main:Section({name = "UI Bind", side = "right", size = 1, default = true}) -- Place UI bind in its own section
        uiBindSection:Keybind({name = "Toggle UI", key = Enum.KeyCode.RightShift, callback = function(isActive) -- Use descriptive name, default RightShift
 window.toggle_menu(isActive) end, default = true, mode = "Toggle"}) -- Default to Toggle mode, start active
    end
--


-- Notification library
    local notifications = library.notifications
    local notificationGui = nil -- Store the notification ScreenGui


     -- Create Notification GUI
     function notifications:CreateGui()
         if notificationGui and notificationGui.Parent then return end -- Already exists


         notificationGui = library:create("ScreenGui", {
             Name = "\0_Notifications",
             Parent = cloneref(game:GetService("CoreGui")),
             Enabled = true,
             ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
             IgnoreGuiInset = true,
             DisplayOrder = 999 -- High display order
         })


          library:create("UIListLayout", { -- Layout for notifications
             Parent = notificationGui;
             FillDirection = Enum.FillDirection.Vertical;
             VerticalAlignment = Enum.VerticalAlignment.Bottom; -- Align to bottom
             HorizontalAlignment = Enum.HorizontalAlignment.Left; -- Align to left
             SortOrder = Enum.SortOrder.LayoutOrder;
             Padding = UDim.new(0, 5); -- Padding between notifications
         })
          library:create("UIPadding", { -- Padding for the whole container
             Parent = notificationGui;
             PaddingLeft = UDim.new(0, 10);
             PaddingBottom = UDim.new(0, 10);
         })
     end



    function notifications:refresh_notifs()
         if not notificationGui or not notificationGui.Parent then return end
         -- No manual refresh needed with UIListLayout aligning to bottom
        --[[ ... refresh logic removed ... ]]--
    end


    function notifications:fade(path, is_fading_out) -- Renamed parameter
         if not path or not path.Parent then return end -- Check if path is valid

         local targetTransparency = is_fading_out and 1 or 0
         local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) -- Faster fade


         -- Fade main outline
         game:GetService("TweenService"):Create(path, tweenInfo, {BackgroundTransparency = targetTransparency}):Play()


         -- Fade children
         for _, instance in ipairs(path:GetDescendants()) do -- Use ipairs
             if instance:IsA("UIStroke") then
            game:GetService("TweenService"):Create(instance, tweenInfo, {Transparency = targetTransparency}):Play()
             elseif instance:IsA("TextLabel") then
                 game:GetService("TweenService"):Create(instance, tweenInfo, {TextTransparency = targetTransparency}):Play()
             elseif instance:IsA("Frame") and instance.Name ~= "line" and instance.Name ~= "accent" then -- Don't fade line/accent background directly
                 game:GetService("TweenService"):Create(instance, tweenInfo, {BackgroundTransparency = targetTransparency}):Play()
             elseif instance:IsA("ImageLabel") then -- Fade images if any
                  game:GetService("TweenService"):Create(instance, tweenInfo, {ImageTransparency = targetTransparency}):Play()
             elseif instance.Name == "line" or instance.Name == "accent" then -- Fade line/accent color instead of background
                  game:GetService("TweenService"):Create(instance, tweenInfo, {BackgroundColor3 = instance.BackgroundColor3:Lerp(Color3.fromRGB(21, 21, 21), targetTransparency)}):Play() -- Lerp towards background color
          end
        end
    end


    function library:Notify(options)
         notifications:CreateGui() -- Ensure GUI exists


        local cfg = {
            name = options.name or "Notification Text", -- Simpler default
            color = options.color or Color3.fromRGB(0, 160, 255); -- Default blue color
 clickable = options.click or false;
             duration = options.duration or 3; -- Default duration 3 seconds
        }


        -- Instances
            local outline = library:create("TextButton", {
                Parent = notificationGui; -- Parent to notification gui
                Size = UDim2.new(0, 0, 0, 0); -- Auto size
                BorderColor3 = Color3.fromRGB(0, 0, 0);
             BorderSizePixel = 1; -- Add border
                AutoButtonColor = false;
                Text = "";
                AutomaticSize = Enum.AutomaticSize.XY;
                BackgroundColor3 = Color3.fromRGB(46, 46, 46);
                BackgroundTransparency = 1; -- Start transparent for fade in
                LayoutOrder = tick(); -- Use tick for unique layout order (newest at bottom)
                Name = "Notification_" .. string.sub(cfg.name, 1, 10); -- Descriptive name
           });


            local inline = library:create("Frame", {
                Parent = outline;
                Position = UDim2.new(0, 1, 0, 1);
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                BorderSizePixel = 0;
                AutomaticSize = Enum.AutomaticSize.XY;
                BackgroundColor3 = Color3.fromRGB(21, 21, 21);
                 BackgroundTransparency = 1; -- Start transparent
                 Name = "\0_Inline";
            });
--[[ ... gradient removal ... ]]--


            library:create("UIPadding", {
                PaddingTop = UDim.new(0, 7);
                PaddingBottom = UDim.new(0, 6);
                Parent = inline;
                PaddingRight = UDim.new(0, 8);
                PaddingLeft = UDim.new(0, 4) -- Adjust left padding if accent line is used
           });


            local misc_text = library:create("TextLabel", {
                FontFace = library.font;
                Parent = inline;
               -- LineHeight = 1.75; -- Adjust if needed
                TextColor3 = Color3.fromRGB(255, 255, 255);
    BorderColor3 = Color3.fromRGB(0, 0, 0);
                Text = cfg.name; -- Use provided name directly
                AutomaticSize = Enum.AutomaticSize.XY;
               -- Size = UDim2.new(1, -4, 1, 0); -- Use automatic size
               -- Position = UDim2.new(0, 4, 0, -2); -- Position handled by padding
        BackgroundTransparency = 1;
                TextXAlignment = Enum.TextXAlignment.Left;
                BorderSizePixel = 0;
                ZIndex = 2;
                TextSize = 10;
                BackgroundColor3 = Color3.fromRGB(255, 255, 255);
                 TextTransparency = 1; -- Start transparent
                 Name = "\0_Text";
            });
             library:create("UIStroke", {Parent = misc_text});


--[[ ... padding removal ... ]]--
 local line = library:create( "Frame" , { -- Bottom line timer
                Parent = outline;
                Name = "line";
                Position = UDim2.new(0, 1, 1, -1); -- Position at bottom inside border
                BorderColor3 = Color3.fromRGB(0, 0, 0);
                Size = UDim2.new(1, -2, 0, 1); -- Full width inside border, 1px height
                BorderSizePixel = 0;
                BackgroundColor3 = cfg.color;
                BackgroundTransparency = 1; -- Start transparent
                 ZIndex = 3; -- Above background
            });
 --[[ ... accent line removal ... ]]--
 --


        -- Fade In Animation
        notifications:fade(outline, false)


        -- Handle Clickable or Timed Fade Out
        local connection
        local timerTween = nil
        local function destroyNotif()
             if not outline or not outline.Parent then return end -- Already destroyed
             if connection then connection:Disconnect(); connection = nil end
             if timerTween then timerTween:Cancel(); timerTween = nil end -- Cancel timer tween if exists
             notifications:fade(outline, true) -- Fade out
             task.delay(0.5, function() -- Wait for fade out before destroying
                  if outline and outline.Parent then pcall(function() outline:Destroy() end) end
             end)
        end


        if cfg.clickable then
            connection = outline.MouseButton1Click:Connect(destroyNotif)
        else
            -- Start timer line animation
             timerTween = game:GetService("TweenService"):Create(line, TweenInfo.new(cfg.duration, Enum.EasingStyle.Linear), {Size = UDim2.new(0, 0, 0, 1)}) -- Animate width to 0
             timerTween:Play()
             timerTween.Completed:Connect(destroyNotif) -- Use Completed event instead of task.delay

            --[[ -- Old task.delay logic
            task.delay(cfg.duration, function()
                 if outline and outline.Parent then -- Check again before destroying
                    destroyNotif()
                 end
             end)
             ]]--
        end
   end -- End of library:Notify
end -- End of Notification library section

-- End of script
